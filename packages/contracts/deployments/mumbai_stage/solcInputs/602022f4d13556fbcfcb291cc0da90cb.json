{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967Upgradeable {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/IERC1967Upgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\n     * 0 before setting it to a non-zero value.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be burned (destroyed).\n */\nabstract contract ERC721BurnableUpgradeable is Initializable, ContextUpgradeable, ERC721Upgradeable {\n    function __ERC721Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _burn(tokenId);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (token/ERC721/extensions/ERC721Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../security/PausableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC721 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract unpausable.\n */\nabstract contract ERC721PausableUpgradeable is Initializable, ERC721Upgradeable, PausableUpgradeable {\n    function __ERC721Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __ERC721Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n\n        require(!paused(), \"ERC721Pausable: token transfer while paused\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165CheckerUpgradeable {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165Upgradeable).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165Upgradeable.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMathUpgradeable {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SignedMathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../Proxy.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../../access/Ownable.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor(address implementation_) {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableBeacon: implementation is not a contract\");\n        _implementation = newImplementation;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/IERC1967.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _burn(tokenId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/ETS.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title ETS\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  ███████╗████████╗███████╗\n *  ██╔════╝╚══██╔══╝██╔════╝\n *  █████╗     ██║   ███████╗\n *  ██╔══╝     ██║   ╚════██║\n *  ███████╗   ██║   ███████║\n *  ╚══════╝   ╚═╝   ╚══════╝\n *\n * @notice This is the core ETS tagging contract that records TaggingRecords to the blockchain.\n * It also contains some governance functions around tagging fees as well as means for market\n * participants to access accrued funds.\n */\n\npragma solidity ^0.8.10;\n\nimport { IETS } from \"./interfaces/IETS.sol\";\nimport { IETSToken } from \"./interfaces/IETSToken.sol\";\nimport { IETSTarget } from \"./interfaces/IETSTarget.sol\";\nimport { IETSAccessControls } from \"./interfaces/IETSAccessControls.sol\";\nimport { UintArrayUtils } from \"./libraries/UintArrayUtils.sol\";\nimport { ContextUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\ncontract ETS is IETS, Initializable, ContextUpgradeable, ReentrancyGuardUpgradeable, UUPSUpgradeable {\n    using UintArrayUtils for uint256[];\n\n    // Public variables\n\n    /// @dev ETS access controls contract.\n    IETSAccessControls public etsAccessControls;\n\n    /// @dev CTAG erc-721 token contract.\n    IETSToken public etsToken;\n\n    /// @dev ETS Targets contract.\n    IETSTarget public etsTarget;\n\n    /// @dev Fee in MATIC Collected by ETS for tagging.\n    uint256 public override taggingFee;\n\n    /// @dev Percentage of tagging fee allocated to ETS.\n    uint256 public platformPercentage;\n\n    /// @dev Percentage of tagging fee allocated to Relayer.\n    uint256 public relayerPercentage;\n\n    /// @dev Map for holding amount accrued to participant address wallets.\n    mapping(address => uint256) public accrued;\n\n    /// @dev Map for holding lifetime amount drawn down from accrued by participants.\n    mapping(address => uint256) public paid;\n\n    /// @dev Map of tagging id to tagging record.\n    mapping(uint256 => TaggingRecord) public taggingRecords;\n\n    /// Public constants\n\n    string public constant NAME = \"ETS Core\";\n    uint256 public constant MODULO = 100;\n\n    /// Modifiers\n\n    /// @dev When applied to a method, only allows execution when the sender has the admin role.\n    modifier onlyAdmin() {\n        require(etsAccessControls.isAdmin(_msgSender()), \"Caller not Administrator\");\n        _;\n    }\n\n    modifier onlyRelayer() {\n        require(etsAccessControls.isRelayer(_msgSender()), \"Caller not Relayer\");\n        _;\n    }\n\n    /// @dev Require that caller is original relayer or tagger.\n    modifier onlyOriginalRelayerOrTagger(uint256 _taggingRecordId) {\n        require(\n            (taggingRecords[_taggingRecordId].relayer == _msgSender() && etsAccessControls.isRelayer(_msgSender())) ||\n                taggingRecords[_taggingRecordId].tagger == _msgSender(),\n            \"Not authorized\"\n        );\n        _;\n    }\n\n    // ============ UUPS INTERFACE ============\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        IETSAccessControls _etsAccessControls,\n        IETSToken _etsToken,\n        IETSTarget _etsTarget,\n        uint256 _taggingFee,\n        uint256 _platformPercentage,\n        uint256 _relayerPercentage\n    ) public initializer {\n        etsAccessControls = _etsAccessControls;\n        etsToken = _etsToken;\n        etsTarget = _etsTarget;\n        setTaggingFee(_taggingFee);\n        setPercentages(_platformPercentage, _relayerPercentage);\n    }\n\n    // Ensure that only address with admin role can upgrade.\n    // solhint-disable-next-line\n    function _authorizeUpgrade(address) internal override onlyAdmin {}\n\n    // ============ OWNER INTERFACE ============\n\n    /**\n     * @notice Sets ETSAccessControls on the ETSTarget contract so functions can be\n     * restricted to ETS platform only. Note Caller of this function must be deployer\n     * or pre-set as admin of new contract.\n     *\n     * @param _accessControls Address of ETSAccessControls contract.\n     */\n    function setAccessControls(IETSAccessControls _accessControls) public onlyAdmin {\n        require(address(_accessControls) != address(0), \"Address cannot be zero\");\n        require(_accessControls.isAdmin(_msgSender()), \"Caller not admin in new contract\");\n        etsAccessControls = _accessControls;\n        emit AccessControlsSet(address(etsAccessControls));\n    }\n\n    /// @notice Sets the fee required to tag an NFT asset.\n    /// @param _fee Value of the fee in WEI.\n    function setTaggingFee(uint256 _fee) public onlyAdmin {\n        taggingFee = _fee;\n        emit TaggingFeeSet(taggingFee);\n    }\n\n    /// @notice Admin functionality for updating the percentages.\n    /// @param _platformPercentage percentage for platform.\n    /// @param _relayerPercentage percentage for relayer.\n    function setPercentages(uint256 _platformPercentage, uint256 _relayerPercentage) public onlyAdmin {\n        require(_platformPercentage + _relayerPercentage <= 100, \"percentages must not be over 100\");\n        platformPercentage = _platformPercentage;\n        relayerPercentage = _relayerPercentage;\n\n        emit PercentagesSet(platformPercentage, relayerPercentage);\n    }\n\n    // ============ PUBLIC INTERFACE ============\n\n    /// @inheritdoc IETS\n    function createTaggingRecord(\n        uint256[] memory _tagIds,\n        uint256 _targetId,\n        string calldata _recordType,\n        address _tagger\n    ) public payable nonReentrant onlyRelayer {\n        uint256 tagCount = _tagIds.length;\n        require(tagCount > 0, \"No tags supplied\");\n        for (uint256 i; i < tagCount; ++i) {\n            require(etsToken.tagExistsById(_tagIds[i]), \"Invalid tagId\");\n        }\n        require(bytes(_recordType).length >= 3 && bytes(_recordType).length < 31, \"Record type too long\");\n        require(etsTarget.targetExistsById(_targetId), \"Invalid targetId\");\n        _processTaggingFees(_tagIds);\n        _createTaggingRecord(_tagIds, _targetId, _recordType, _msgSender(), _tagger);\n    }\n\n    /// @inheritdoc IETS\n    function getOrCreateTagId(\n        string calldata _tag,\n        address payable _creator\n    ) public payable onlyRelayer returns (uint256 tokenId) {\n        return etsToken.getOrCreateTagId(_tag, payable(_msgSender()), _creator);\n    }\n\n    /// @inheritdoc IETS\n    function createTag(\n        string calldata _tag,\n        address payable _creator\n    ) public payable nonReentrant onlyRelayer returns (uint256 _tokenId) {\n        return etsToken.createTag(_tag, payable(_msgSender()), _creator);\n    }\n\n    /// @inheritdoc IETS\n    function applyTagsWithRawInput(TaggingRecordRawInput calldata _rawInput, address payable _tagger) public payable {\n        // Derive tagIds for the tagStrings.\n        uint256 tagCount = _rawInput.tagStrings.length;\n        require(tagCount > 0, \"No tags supplied\");\n\n        uint256[] memory tagIds = new uint256[](tagCount);\n        for (uint256 i; i < tagCount; ++i) {\n            tagIds[i] = getOrCreateTagId(_rawInput.tagStrings[i], _tagger);\n        }\n\n        uint256 taggingRecordId = computeTaggingRecordIdFromRawInput(_rawInput, _msgSender(), _tagger);\n\n        if (taggingRecordExists(taggingRecordId)) {\n            appendTags(taggingRecordId, tagIds);\n        } else {\n            // Derive targetId from targetURI. Will revert if targetURI is empty.\n            uint256 targetId = etsTarget.getOrCreateTargetId(_rawInput.targetURI);\n            // Require new tagging records be inserted by relayer.\n            createTaggingRecord(tagIds, targetId, _rawInput.recordType, _tagger);\n        }\n    }\n\n    /// @inheritdoc IETS\n    function applyTagsWithCompositeKey(\n        uint256[] memory _tagIds,\n        uint256 _targetId,\n        string calldata _recordType,\n        address payable _tagger\n    ) public payable {\n        uint256 tagCount = _tagIds.length;\n        require(tagCount > 0, \"No tags supplied\");\n\n        uint256 taggingRecordId = computeTaggingRecordIdFromCompositeKey(_targetId, _recordType, _msgSender(), _tagger);\n        if (taggingRecordExists(taggingRecordId)) {\n            appendTags(taggingRecordId, _tagIds);\n        } else {\n            createTaggingRecord(_tagIds, _targetId, _recordType, _tagger);\n        }\n    }\n\n    /// @inheritdoc IETS\n    function replaceTagsWithRawInput(TaggingRecordRawInput calldata _rawInput, address payable _tagger) public payable {\n        uint256 tagCount = _rawInput.tagStrings.length;\n        require(tagCount > 0, \"No tags supplied\");\n\n        uint256[] memory tagIds = new uint256[](tagCount);\n        for (uint256 i; i < tagCount; ++i) {\n            tagIds[i] = getOrCreateTagId(_rawInput.tagStrings[i], _tagger);\n        }\n\n        replaceTags(computeTaggingRecordIdFromRawInput(_rawInput, _msgSender(), _tagger), tagIds);\n    }\n\n    /// @inheritdoc IETS\n    function replaceTagsWithCompositeKey(\n        uint256[] calldata _tagIds,\n        uint256 _targetId,\n        string memory _recordType,\n        address payable _tagger\n    ) public payable {\n        replaceTags(computeTaggingRecordIdFromCompositeKey(_targetId, _recordType, _msgSender(), _tagger), _tagIds);\n    }\n\n    /// @inheritdoc IETS\n    function removeTagsWithRawInput(TaggingRecordRawInput calldata _rawInput, address _tagger) public {\n        uint256 rawTagCount = _rawInput.tagStrings.length;\n        uint256[] memory tagIds = new uint256[](rawTagCount);\n        for (uint256 i; i < rawTagCount; ++i) {\n            tagIds[i] = etsToken.computeTagId(_rawInput.tagStrings[i]);\n        }\n        removeTags(computeTaggingRecordIdFromRawInput(_rawInput, _msgSender(), _tagger), tagIds);\n    }\n\n    /// @inheritdoc IETS\n    function removeTagsWithCompositeKey(\n        uint256[] calldata _tagIds,\n        uint256 _targetId,\n        string memory _recordType,\n        address payable _tagger\n    ) public {\n        removeTags(computeTaggingRecordIdFromCompositeKey(_targetId, _recordType, _msgSender(), _tagger), _tagIds);\n    }\n\n    /// @inheritdoc IETS\n    function appendTags(\n        uint256 _taggingRecordId,\n        uint256[] memory _tagIds\n    ) public payable nonReentrant onlyOriginalRelayerOrTagger(_taggingRecordId) {\n        require(_tagIds.length > 0, \"No tags supplied\");\n\n        // Filter out new tags from the supplied tags.\n        _tagIds = UintArrayUtils.difference(_tagIds, taggingRecords[_taggingRecordId].tagIds);\n\n        if (_tagIds.length > 0) {\n            _processTaggingFees(_tagIds);\n            _appendTags(_taggingRecordId, _tagIds);\n        }\n    }\n\n    /// @inheritdoc IETS\n    function replaceTags(\n        uint256 _taggingRecordId,\n        uint256[] memory _tagIds\n    ) public payable nonReentrant onlyOriginalRelayerOrTagger(_taggingRecordId) {\n        require(_tagIds.length > 0, \"No tags supplied\");\n\n        // Find all the tags NOT SHARED by the tagging record and the replacement set.\n        uint256[] memory notShared = UintArrayUtils.difference(taggingRecords[_taggingRecordId].tagIds, _tagIds);\n\n        // Remove these from the tagging record.\n        if (notShared.length > 0) {\n            _removeTags(_taggingRecordId, notShared);\n        }\n\n        // Filter out new tags from the replacement set\n        _tagIds = UintArrayUtils.difference(_tagIds, taggingRecords[_taggingRecordId].tagIds);\n\n        if (_tagIds.length > 0) {\n            _processTaggingFees(_tagIds);\n            _appendTags(_taggingRecordId, _tagIds);\n        }\n    }\n\n    /// @inheritdoc IETS\n    function removeTags(\n        uint256 _taggingRecordId,\n        uint256[] memory _tagIds\n    ) public nonReentrant onlyOriginalRelayerOrTagger(_taggingRecordId) {\n        require(_tagIds.length > 0, \"No tags supplied\");\n\n        // Find tags shared by supplied tags and tagging record tags.\n        _tagIds = UintArrayUtils.intersect(_tagIds, taggingRecords[_taggingRecordId].tagIds);\n\n        if (_tagIds.length > 0) {\n            // No tagging fee when tags are removed.\n            _removeTags(_taggingRecordId, _tagIds);\n        }\n    }\n\n    /// @inheritdoc IETS\n    function drawDown(address payable _account) external nonReentrant {\n        uint256 balanceDue = totalDue(_account);\n        if (balanceDue > 0 && balanceDue <= address(this).balance) {\n            paid[_account] = paid[_account] + balanceDue;\n\n            (bool success, ) = _account.call{ value: balanceDue }(\"\");\n            require(success, \"Transfer failed.\");\n\n            emit FundsWithdrawn(_account, balanceDue);\n        }\n    }\n\n    // ============ PUBLIC VIEW FUNCTIONS ============\n\n    /// @inheritdoc IETS\n    function computeTaggingRecordIdFromRawInput(\n        TaggingRecordRawInput memory _rawInput,\n        address _relayer,\n        address _tagger\n    ) public view returns (uint256 taggingRecordId) {\n        return\n            computeTaggingRecordIdFromCompositeKey(\n                etsTarget.computeTargetId(_rawInput.targetURI),\n                _rawInput.recordType,\n                _relayer,\n                _tagger\n            );\n    }\n\n    /// @inheritdoc IETS\n    function computeTaggingRecordIdFromCompositeKey(\n        uint256 _targetId,\n        string memory _recordType,\n        address _relayer,\n        address _tagger\n    ) public pure returns (uint256 taggingRecordId) {\n        taggingRecordId = uint256(keccak256(abi.encodePacked(_targetId, _recordType, _relayer, _tagger)));\n    }\n\n    /// @inheritdoc IETS\n    function computeTaggingFeeFromRawInput(\n        TaggingRecordRawInput calldata _rawInput,\n        address _relayer,\n        address _tagger,\n        TaggingAction _action\n    ) public view returns (uint256 fee, uint256 tagCount) {\n        uint256 rawTagCount = _rawInput.tagStrings.length;\n        uint256[] memory tagIds = new uint256[](rawTagCount);\n        for (uint256 i; i < rawTagCount; ++i) {\n            tagIds[i] = etsToken.computeTagId(_rawInput.tagStrings[i]);\n        }\n        return computeTaggingFee(computeTaggingRecordIdFromRawInput(_rawInput, _relayer, _tagger), tagIds, _action);\n    }\n\n    /// @inheritdoc IETS\n    function computeTaggingFeeFromCompositeKey(\n        uint256[] memory _tagIds,\n        uint256 _targetId,\n        string calldata _recordType,\n        address _relayer,\n        address _tagger,\n        TaggingAction _action\n    ) public view returns (uint256 fee, uint256 tagCount) {\n        return\n            computeTaggingFee(\n                computeTaggingRecordIdFromCompositeKey(_targetId, _recordType, _relayer, _tagger),\n                _tagIds,\n                _action\n            );\n    }\n\n    /// @inheritdoc IETS\n    function computeTaggingFee(\n        uint256 _taggingRecordId,\n        uint256[] memory _tagIds,\n        TaggingAction _action\n    ) public view returns (uint256 fee, uint256 tagCount) {\n        // Return quickly when no tagging record exists.\n        if (!taggingRecordExists(_taggingRecordId)) {\n            return (_computeTaggingFee(_tagIds.length), _tagIds.length);\n        }\n\n        if (TaggingAction(_action) == TaggingAction.APPEND) {\n            // remove tagging record tag ids from input tag ids to return number of new tags applied.\n            _tagIds = UintArrayUtils.difference(_tagIds, taggingRecords[_taggingRecordId].tagIds);\n        }\n\n        if (TaggingAction(_action) == TaggingAction.REPLACE) {\n            // Remove tags from tagging record not in replacement tag set.\n            uint256[] memory taggingRecordTags = taggingRecords[_taggingRecordId].tagIds;\n            uint256[] memory tagsToRemove = UintArrayUtils.difference(taggingRecords[_taggingRecordId].tagIds, _tagIds);\n            if (tagsToRemove.length > 0) {\n                taggingRecordTags = UintArrayUtils.difference(taggingRecords[_taggingRecordId].tagIds, tagsToRemove);\n            }\n\n            _tagIds = UintArrayUtils.difference(_tagIds, taggingRecordTags);\n        }\n\n        if (TaggingAction(_action) == TaggingAction.REMOVE) {\n            // Find tags shared by supplied tags and tagging record tags.\n            _tagIds = UintArrayUtils.intersect(_tagIds, taggingRecords[_taggingRecordId].tagIds);\n\n            // No fee charged for removing tags at the present time, but still nice to give\n            // clients a way to know how many tags will be removed.\n            return (0, _tagIds.length);\n        }\n\n        return (_computeTaggingFee(_tagIds.length), _tagIds.length);\n    }\n\n    /// @inheritdoc IETS\n    function getTaggingRecordFromRawInput(\n        TaggingRecordRawInput memory _rawInput,\n        address _relayer,\n        address _tagger\n    )\n        public\n        view\n        returns (uint256[] memory tagIds, uint256 targetId, string memory recordType, address relayer, address tagger)\n    {\n        return\n            this.getTaggingRecordFromId(\n                computeTaggingRecordIdFromCompositeKey(\n                    etsTarget.computeTargetId(_rawInput.targetURI),\n                    _rawInput.recordType,\n                    _relayer,\n                    _tagger\n                )\n            );\n    }\n\n    /// @inheritdoc IETS\n    function getTaggingRecordFromCompositeKey(\n        uint256 _targetId,\n        string memory _recordType,\n        address _relayer,\n        address _tagger\n    )\n        public\n        view\n        returns (uint256[] memory tagIds, uint256 targetId, string memory recordType, address relayer, address tagger)\n    {\n        return\n            this.getTaggingRecordFromId(\n                computeTaggingRecordIdFromCompositeKey(_targetId, _recordType, _relayer, _tagger)\n            );\n    }\n\n    /// @inheritdoc IETS\n    function getTaggingRecordFromId(\n        uint256 _id\n    )\n        public\n        view\n        returns (uint256[] memory tagIds, uint256 targetId, string memory recordType, address relayer, address tagger)\n    {\n        TaggingRecord storage taggingRecord = taggingRecords[_id];\n        return (\n            taggingRecord.tagIds,\n            taggingRecord.targetId,\n            taggingRecord.recordType,\n            taggingRecord.relayer,\n            taggingRecord.tagger\n        );\n    }\n\n    /// @inheritdoc IETS\n    function taggingRecordExistsByRawInput(\n        TaggingRecordRawInput memory _rawInput,\n        address _relayer,\n        address _tagger\n    ) public view returns (bool) {\n        return\n            taggingRecordExists(\n                computeTaggingRecordIdFromCompositeKey(\n                    etsTarget.computeTargetId(_rawInput.targetURI),\n                    _rawInput.recordType,\n                    _relayer,\n                    _tagger\n                )\n            );\n    }\n\n    /// @inheritdoc IETS\n    function taggingRecordExistsByCompositeKey(\n        uint256 _targetId,\n        string memory _recordType,\n        address _relayer,\n        address _tagger\n    ) public view returns (bool) {\n        return taggingRecordExists(computeTaggingRecordIdFromCompositeKey(_targetId, _recordType, _relayer, _tagger));\n    }\n\n    /// @inheritdoc IETS\n    function taggingRecordExists(uint256 _taggingRecordId) public view returns (bool) {\n        return taggingRecords[_taggingRecordId].targetId != 0 ? true : false;\n    }\n\n    /// @inheritdoc IETS\n    function totalDue(address _account) public view returns (uint256 _due) {\n        return accrued[_account] - paid[_account];\n    }\n\n    // ============ INTERNAL FUNCTIONS ============\n\n    /// @dev write a tagging record, mapping a taggingRecordId to a TaggingRecord struct.\n    function _createTaggingRecord(\n        uint256[] memory _tagIds,\n        uint256 _targetId,\n        string calldata _recordType,\n        address _relayer,\n        address _tagger\n    ) private {\n        uint256 taggingRecordId = computeTaggingRecordIdFromCompositeKey(_targetId, _recordType, _relayer, _tagger);\n        taggingRecords[taggingRecordId] = TaggingRecord({\n            tagIds: _tagIds,\n            targetId: _targetId,\n            recordType: _recordType,\n            relayer: _relayer,\n            tagger: _tagger\n        });\n\n        emit TaggingRecordCreated(taggingRecordId);\n    }\n\n    /**\n     * @dev Append tags to a tagging record\n     */\n    function _appendTags(uint256 _taggingRecordId, uint256[] memory _tagIds) private {\n        // Merge _newTagIds with existing tags.\n        taggingRecords[_taggingRecordId].tagIds = UintArrayUtils.extend(\n            taggingRecords[_taggingRecordId].tagIds,\n            _tagIds\n        );\n        emit TaggingRecordUpdated(_taggingRecordId, TaggingAction.APPEND);\n    }\n\n    /**\n     * @dev Remove tags from tagging record.\n     *\n     * @param _taggingRecordId tagging record being updated.\n     * @param _tagIds tagId to remove from tagging record.\n     */\n    function _removeTags(\n        uint256 _taggingRecordId,\n        uint256[] memory _tagIds\n    ) private onlyOriginalRelayerOrTagger(_taggingRecordId) {\n        taggingRecords[_taggingRecordId].tagIds = UintArrayUtils.difference(\n            taggingRecords[_taggingRecordId].tagIds,\n            _tagIds\n        );\n        emit TaggingRecordUpdated(_taggingRecordId, TaggingAction.REMOVE);\n    }\n\n    function _computeTaggingFee(uint256 _tagCount) internal view returns (uint256 _fee) {\n        uint256 fee = 0;\n        if (_tagCount > 0 && taggingFee > 0) {\n            fee = _tagCount * taggingFee;\n        }\n        return (fee);\n    }\n\n    function _processTaggingFees(uint256[] memory _tagIds) private {\n        require((msg.value == _computeTaggingFee(_tagIds.length)), \"wrong fee supplied\");\n        address platform = etsAccessControls.getPlatformAddress();\n        for (uint256 i; i < _tagIds.length; ++i) {\n            _processAccrued(_tagIds[i], platform);\n        }\n    }\n\n    // @dev Internal function to divide up the tagging fee and accrue it to ETS participants.\n    function _processAccrued(uint256 _tagId, address _platform) private {\n        // Note: This will cause _processTaggingFees to revert if tagId doesn't exist.\n        address owner = etsToken.ownerOf(_tagId);\n        IETSToken.Tag memory tag = etsToken.getTagById(_tagId);\n\n        uint256 platformAllocation = (msg.value * platformPercentage) / MODULO;\n        uint256 relayerAllocation = (msg.value * relayerPercentage) / MODULO;\n        uint256 remainingAllocation = msg.value - (platformAllocation + relayerAllocation);\n\n        accrued[_platform] = accrued[_platform] + platformAllocation;\n        accrued[tag.relayer] = accrued[tag.relayer] + relayerAllocation;\n\n        // pre-auction.\n        if (owner == _platform) {\n            accrued[tag.creator] = accrued[tag.creator] + remainingAllocation;\n        }\n        // post-auction.\n        else {\n            accrued[owner] = accrued[owner] + remainingAllocation;\n        }\n    }\n}\n"
    },
    "contracts/ETSAccessControls.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title IETSAccessControls\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  ███████╗████████╗███████╗\n *  ██╔════╝╚══██╔══╝██╔════╝\n *  █████╗     ██║   ███████╗\n *  ██╔══╝     ██║   ╚════██║\n *  ███████╗   ██║   ███████║\n *  ╚══════╝   ╚═╝   ╚══════╝\n *\n * @notice This is the interface for the ETSAccessControls contract which allows ETS Core Dev\n * Team to administer roles and control access to various parts of the ETS Platform.\n * ETSAccessControls contract contains a mix of public and administrator only functions.\n */\n\npragma solidity ^0.8.10;\n\nimport { IETSAccessControls } from \"./interfaces/IETSAccessControls.sol\";\nimport { IETSRelayer } from \"./relayers/interfaces/IETSRelayer.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport { ERC165CheckerUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\";\n\ncontract ETSAccessControls is Initializable, AccessControlUpgradeable, IETSAccessControls, UUPSUpgradeable {\n    /// Public constants\n    string public constant NAME = \"ETS access controls\";\n    bytes32 public constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\n    bytes32 public constant RELAYER_FACTORY_ROLE = keccak256(\"RELAYER_FACTORY_ROLE\");\n    bytes32 public constant RELAYER_ADMIN_ROLE = keccak256(\"RELAYER_ADMIN_ROLE\");\n    bytes32 public constant AUCTION_ORACLE_ROLE = keccak256(\"AUCTION_ORACLE_ROLE\");\n    bytes32 public constant SMART_CONTRACT_ROLE = keccak256(\"SMART_CONTRACT_ROLE\");\n\n    /// @dev ETS Platform account. Core Dev Team multisig in production.\n    /// There will only be one \"Platform\" so no need to make it a role.\n    address payable internal platform;\n\n    /// @notice Mapping to contain whether Relayer is paused by the protocol.\n    mapping(address => bool) public relayerLocked;\n\n    /// @notice Relayer name to contract address.\n    mapping(string => address) public relayerNameToContract;\n\n    /// @notice Relayer contract address to human readable name.\n    mapping(address => string) public relayerContractToName;\n\n    /// @notice Relayer owner address to relayer address.\n    mapping(address => address) public relayerOwnerToAddress;\n\n    modifier onlyValidName(string calldata _name) {\n        require(!isRelayerByName(_name), \"Relayer name exists\");\n        bytes memory nameBytes = bytes(_name);\n        require(nameBytes.length >= 2, \"Relayer name too short\");\n        require(nameBytes.length <= 32, \"Relayer name too long\");\n        _;\n    }\n\n    // ============ UUPS INTERFACE ============\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _platformAddress) public initializer {\n        __AccessControl_init();\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        setPlatform(payable(_platformAddress));\n    }\n\n    // Ensure that only addresses with admin role can upgrade.\n    // solhint-disable-next-line\n    function _authorizeUpgrade(address) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}\n\n    // ============ OWNER INTERFACE ============\n\n    /// @inheritdoc IETSAccessControls\n    function setPlatform(address payable _platform) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        address prevAddress = platform;\n        platform = _platform;\n        grantRole(DEFAULT_ADMIN_ROLE, _platform);\n        emit PlatformSet(_platform, prevAddress);\n    }\n\n    /// @inheritdoc IETSAccessControls\n    function setRoleAdmin(bytes32 _role, bytes32 _adminRole) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setRoleAdmin(_role, _adminRole);\n    }\n\n    /// @inheritdoc IETSAccessControls\n    function registerRelayer(\n        address _relayer,\n        string calldata _name,\n        address _owner\n    ) public onlyRole(RELAYER_FACTORY_ROLE) {\n        relayerNameToContract[_name] = _relayer;\n        relayerContractToName[_relayer] = _name;\n        relayerOwnerToAddress[_owner] = _relayer;\n        relayerLocked[_relayer] = false;\n        // Note: grantRole emits RoleGranted event.\n        grantRole(RELAYER_ROLE, _relayer);\n        emit RelayerAdded(_relayer);\n    }\n\n    /// @inheritdoc IETSAccessControls\n    function pauseRelayerByOwnerAddress(address _relayerOwner) public onlyRole(RELAYER_ADMIN_ROLE) {\n        if (isRelayerByOwner(_relayerOwner)) {\n            IETSRelayer relayer = IETSRelayer(getRelayerAddressFromOwner(_relayerOwner));\n            if (!relayer.isPaused()) {\n                relayer.pause();\n            }\n        }\n    }\n\n    /// @inheritdoc IETSAccessControls\n    function changeRelayerOwner(address _currentOwner, address _newOwner) public onlyRole(RELAYER_ROLE) {\n        require(isRelayerByAddress(_msgSender()), \"Caller is not relayer\");\n        require(IETSRelayer(_msgSender()).getOwner() == _currentOwner, \"Not relayer owner\");\n        require(!isRelayerByOwner(_newOwner), \"New owner already owns a relayer\");\n        relayerOwnerToAddress[_currentOwner] = address(0);\n        // _msgSender() is the relayer itself.\n        relayerOwnerToAddress[_newOwner] = _msgSender();\n    }\n\n    /// @inheritdoc IETSAccessControls\n    function toggleRelayerLock(address _relayer) public onlyRole(RELAYER_ADMIN_ROLE) {\n        relayerLocked[_relayer] = !relayerLocked[_relayer];\n        emit RelayerLockToggled(_relayer);\n    }\n\n    // ============ PUBLIC VIEW FUNCTIONS ============\n\n    /// @inheritdoc IETSAccessControls\n    function isSmartContract(address _addr) public view returns (bool) {\n        return hasRole(SMART_CONTRACT_ROLE, _addr);\n    }\n\n    /// @inheritdoc IETSAccessControls\n    function isAdmin(address _addr) public view returns (bool) {\n        return hasRole(DEFAULT_ADMIN_ROLE, _addr);\n    }\n\n    /// @inheritdoc IETSAccessControls\n    function isAuctionOracle(address _addr) public view returns (bool) {\n        return hasRole(AUCTION_ORACLE_ROLE, _addr);\n    }\n\n    /// @inheritdoc IETSAccessControls\n    function isRelayerFactory(address _addr) public view returns (bool) {\n        return hasRole(RELAYER_ADMIN_ROLE, _addr) || hasRole(RELAYER_FACTORY_ROLE, _addr);\n    }\n\n    /// @inheritdoc IETSAccessControls\n    function isRelayer(address _addr) public view returns (bool) {\n        return hasRole(RELAYER_ADMIN_ROLE, _addr) || isRelayerAndNotPaused(_addr);\n    }\n\n    /// @inheritdoc IETSAccessControls\n    function isRelayerLocked(address _addr) public view returns (bool) {\n        return relayerLocked[_addr];\n    }\n\n    /// @inheritdoc IETSAccessControls\n    function isRelayerAndNotPaused(address _addr) public view returns (bool) {\n        return isRelayerByAddress(_addr) && !isRelayerLocked(_addr) && !IETSRelayer(_addr).isPaused();\n    }\n\n    /// @inheritdoc IETSAccessControls\n    function isRelayerByOwner(address _addr) public view returns (bool) {\n        return relayerOwnerToAddress[_addr] != address(0);\n    }\n\n    /// @inheritdoc IETSAccessControls\n    function isRelayerAdmin(address _addr) public view returns (bool) {\n        return hasRole(RELAYER_ADMIN_ROLE, _addr);\n    }\n\n    /// @inheritdoc IETSAccessControls\n    function isRelayerByName(string memory _name) public view returns (bool) {\n        return relayerNameToContract[_name] != address(0);\n    }\n\n    /// @inheritdoc IETSAccessControls\n    function isRelayerByAddress(address _addr) public view returns (bool) {\n        return keccak256(abi.encodePacked(relayerContractToName[_addr])) != keccak256(abi.encodePacked(\"\"));\n    }\n\n    /// @inheritdoc IETSAccessControls\n    function getRelayerAddressFromName(string memory _name) public view returns (address) {\n        return relayerNameToContract[_name];\n    }\n\n    /// @inheritdoc IETSAccessControls\n    function getRelayerNameFromAddress(address _address) public view returns (string memory) {\n        return relayerContractToName[_address];\n    }\n\n    /// @inheritdoc IETSAccessControls\n    function getRelayerAddressFromOwner(address _address) public view returns (address) {\n        return relayerOwnerToAddress[_address];\n    }\n\n    /// @inheritdoc IETSAccessControls\n    function getPlatformAddress() public view returns (address payable) {\n        return platform;\n    }\n}\n"
    },
    "contracts/ETSAuctionHouse.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/**\n * @title ETS Auction House\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  ███████╗████████╗███████╗\n *  ██╔════╝╚══██╔══╝██╔════╝\n *  █████╗     ██║   ███████╗\n *  ██╔══╝     ██║   ╚════██║\n *  ███████╗   ██║   ███████║\n *  ╚══════╝   ╚═╝   ╚══════╝\n *\n * @notice ETSAuctionHouse.sol is a modified version of Nouns NounsAuctionHouse.sol:\n * https://github.com/nounsDAO/nouns-monorepo/blob/master/packages/nouns-contracts/contracts/NounsAuctionHouse.sol\n * which itself is a modified version of Zora AuctionHouse.sol\n *\n * AuctionHouse.sol source code Copyright Zora licensed under the GPL-3.0 license.\n * With modifications by Ethereum Tag Service.\n *\n * ETS modification include enabling more than one concurrent auction via a protocol controlled\n * setting and requiring a bid to start the auction timer.\n */\n\npragma solidity ^0.8.6;\n\nimport { IWMATIC } from \"./interfaces/IWMATIC.sol\";\nimport { IETSToken } from \"./interfaces/IETSToken.sol\";\nimport { IETSAuctionHouse } from \"./interfaces/IETSAuctionHouse.sol\";\nimport { IETSAccessControls } from \"./interfaces/IETSAccessControls.sol\";\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { CountersUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title ETSAuctionHouse\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n * @notice ETSAuctionHouse contract governs the sale of Ethereum Tag Service composable tags (CTAGs).\n */\ncontract ETSAuctionHouse is\n    Initializable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    IETSAuctionHouse,\n    UUPSUpgradeable\n{\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    IETSToken public etsToken;\n    IETSAccessControls public etsAccessControls;\n\n    /// Public constants\n\n    string public constant NAME = \"ETS Auction House\";\n    uint256 public constant MODULO = 100;\n\n    /// Public variables\n    uint256 public maxAuctions;\n\n    // Open for bidding\n    CountersUpgradeable.Counter activeAuctions;\n\n    // Unique auction id\n    CountersUpgradeable.Counter auctionId;\n\n    /// @dev Mapping of auction ID to auction.\n    mapping(uint256 => IETSAuctionHouse.Auction) public auctions;\n\n    /// @dev Mapping of tokenId to array of auction ids.\n    mapping(uint256 => uint256[]) public auctionsByTokenId;\n\n    /// @dev Mapping from auctionId to the corresponding tagId\n    //mapping(uint256 => uint256) public auctionIdToTokenId;\n\n    // Mapping from auctionId to the corresponding auction for each token\n    //mapping(uint256 => mapping(uint256 => Auction)) public auctionIdToAuction;\n\n    /// @dev The address of the WMATIC contract\n    address public wmatic;\n\n    /// @dev The minimum amount of time left in an auction after a new bid is created\n    uint256 public timeBuffer;\n\n    /// @dev The minimum price accepted in an auction\n    uint256 public reservePrice;\n\n    /// @dev The minimum percentage difference between the last bid amount and the current bid\n    uint8 public minBidIncrementPercentage;\n\n    /// @dev The duration of a single auction\n    uint256 public duration;\n\n    /// @dev Percentage of auction proceeds allocated to CTAG Creator\n    uint256 public creatorPercentage;\n\n    /// @dev Percentage of auction proceeds allocated to CTAG Relayer.\n    uint256 public relayerPercentage;\n\n    /// @dev Percentage of auction proceeds allocated to ETS.\n    uint256 public platformPercentage;\n\n    /// @dev Map for holding amount accrued to participant address wallets.\n    mapping(address => uint256) public accrued;\n\n    /// @dev Map for holding lifetime amount drawn down from accrued by participants.\n    mapping(address => uint256) public paid;\n\n    /// Modifiers\n\n    modifier tagExists(uint256 tokenId) {\n        require(etsToken.tagExistsById(tokenId), \"CTAG does not exist\");\n        _;\n    }\n\n    modifier platformOwned(uint256 tokenId) {\n        // Returns \"ERC721: owner query for nonexistent token\" for non-existent token.\n        require(etsToken.ownerOf(tokenId) == etsAccessControls.getPlatformAddress(), \"CTAG not owned by ETS\");\n        _;\n    }\n\n    modifier onlyAuctionOracle() {\n        require(etsAccessControls.isAuctionOracle(_msgSender()), \"Caller not auction oracle\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(etsAccessControls.isAdmin(_msgSender()), \"Caller must be administrator\");\n        _;\n    }\n\n    modifier onlyPlatform() {\n        require(etsAccessControls.getPlatformAddress() == _msgSender(), \"Only platform may release CTAG\");\n        _;\n    }\n\n    // ============ UUPS INTERFACE ============\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        IETSToken _etsToken,\n        IETSAccessControls _etsAccessControls,\n        address _wmatic,\n        uint256 _maxAuctions,\n        uint256 _timeBuffer,\n        uint256 _reservePrice,\n        uint8 _minBidIncrementPercentage,\n        uint256 _duration,\n        uint256 _relayerPercentage,\n        uint256 _platformPercentage\n    ) external initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        _pause();\n\n        etsToken = _etsToken;\n        etsAccessControls = _etsAccessControls;\n        wmatic = _wmatic;\n\n        activeAuctions.reset();\n        auctionId.reset();\n\n        setMaxAuctions(_maxAuctions);\n        setMinBidIncrementPercentage(_minBidIncrementPercentage);\n        setDuration(_duration);\n        setReservePrice(_reservePrice);\n        setTimeBuffer(_timeBuffer);\n        setProceedPercentages(_platformPercentage, _relayerPercentage);\n    }\n\n    // solhint-disable-next-line\n    function _authorizeUpgrade(address) internal override onlyAdmin {}\n\n    // ============ OWNER/ADMIN INTERFACE ============\n\n    function pause() public onlyAdmin {\n        _pause();\n    }\n\n    function unpause() public onlyAdmin {\n        _unpause();\n    }\n\n    function setMaxAuctions(uint256 _maxAuctions) public onlyAdmin {\n        maxAuctions = _maxAuctions;\n        emit AuctionsMaxSet(_maxAuctions);\n    }\n\n    function setDuration(uint256 _duration) public onlyAdmin {\n        duration = _duration;\n        emit AuctionDurationSet(_duration);\n    }\n\n    function setMinBidIncrementPercentage(uint8 _minBidIncrementPercentage) public onlyAdmin {\n        minBidIncrementPercentage = _minBidIncrementPercentage;\n        emit AuctionMinBidIncrementPercentageSet(_minBidIncrementPercentage);\n    }\n\n    function setReservePrice(uint256 _reservePrice) public onlyAdmin {\n        reservePrice = _reservePrice;\n        emit AuctionReservePriceSet(_reservePrice);\n    }\n\n    function setTimeBuffer(uint256 _timeBuffer) public onlyAdmin {\n        timeBuffer = _timeBuffer;\n        emit AuctionTimeBufferSet(_timeBuffer);\n    }\n\n    function setProceedPercentages(uint256 _platformPercentage, uint256 _relayerPercentage) public onlyAdmin {\n        require(_platformPercentage + _relayerPercentage <= 100, \"Input must not exceed 100%\");\n        platformPercentage = _platformPercentage;\n        relayerPercentage = _relayerPercentage;\n        creatorPercentage = MODULO - platformPercentage - relayerPercentage;\n\n        emit AuctionProceedPercentagesSet(platformPercentage, relayerPercentage, creatorPercentage);\n    }\n\n    // ============ PUBLIC INTERFACE ============\n\n    /**\n     * @notice Settle auction, and release next auction.\n     */\n    function settleCurrentAndCreateNewAuction(uint256 _auctionId) public nonReentrant whenNotPaused {\n        _settleAuction(_auctionId);\n        _requestCreateAuction();\n    }\n\n    /**\n     * @notice Settle the auction.\n     * @dev This function can only be called when the contract is paused.\n     */\n    function settleAuction(uint256 _auctionId) public whenPaused nonReentrant {\n        _settleAuction(_auctionId);\n    }\n\n    // Public function to release another auction using the auction Oracle.\n    function createNextAuction() public whenNotPaused {\n        require(activeAuctions.current() < maxAuctions, \"No open auction slots\");\n        _requestCreateAuction();\n    }\n\n    // Capture reponse from next auction oracle.\n    function fulfillRequestCreateAuction(uint256 _tokenId) public onlyAuctionOracle {\n        // Let's double check the oracle's work.\n        // Note: First check returns \"ERC721: invalid token ID\" for non-existent token.\n        require(etsToken.ownerOf(_tokenId) == etsAccessControls.getPlatformAddress(), \"CTAG not owned by ETS\");\n        require(activeAuctions.current() < maxAuctions, \"No open auction slots\");\n        // Get the most recent auction for this token.\n        if (auctionExistsForTokenId(_tokenId)) {\n            Auction memory auction = getAuctionForTokenId(_tokenId);\n            require(auction.settled, \"Auction exists\");\n        }\n        _createAuction(_tokenId);\n    }\n\n    function createBid(uint256 _auctionId) public payable nonReentrant whenNotPaused {\n        require(_auctionExists(_auctionId), \"Auction not found\");\n        Auction memory auction = _getAuction(_auctionId);\n        if (auction.startTime > 0) {\n            console.log(block.timestamp);\n            console.log(auction.endTime);\n            require(block.timestamp < auction.endTime, \"Auction ended\");\n        }\n        require(msg.value >= reservePrice, \"Must send at least reservePrice\");\n        require(msg.value >= auction.amount + ((auction.amount * minBidIncrementPercentage) / 100), \"Bid too low\");\n\n        address payable lastBidder = auction.bidder;\n\n        // Refund the last bidder, if applicable\n        if (lastBidder != address(0)) {\n            console.log(\"lastBidder\", lastBidder);\n            console.log(\"auction.amount\", auction.amount);\n            _safeTransferETHWithFallback(lastBidder, auction.amount);\n        }\n\n        if (auction.startTime == 0) {\n            // Start the auction\n            uint256 startTime = block.timestamp;\n            uint256 endTime = startTime + duration;\n            auctions[_auctionId].startTime = startTime;\n            auctions[_auctionId].endTime = endTime;\n        }\n\n        auctions[_auctionId].amount = msg.value;\n        auctions[_auctionId].bidder = payable(msg.sender);\n\n        // Extend the auction if the bid was received within `timeBuffer` of the auction end time\n        bool extended = false;\n        if (auction.startTime > 0) {\n            extended = auction.endTime - block.timestamp < timeBuffer;\n            if (extended) {\n                auctions[_auctionId].endTime = auction.endTime = block.timestamp + timeBuffer;\n                emit AuctionExtended(_auctionId, auction.endTime);\n            }\n        }\n\n        emit AuctionBid(_auctionId, msg.sender, msg.value, extended);\n    }\n\n    /**\n     * @notice Function for withdrawing funds from an accrual account. Can be called by the account owner\n     * or on behalf of the account. Does nothing when there is nothing due to the account.\n     *\n     * @param _account Address of account being drawn down and which will receive the funds.\n     */\n    function drawDown(address payable _account) external nonReentrant {\n        uint256 balanceDue = totalDue(_account);\n        if (balanceDue > 0 && balanceDue <= address(this).balance) {\n            paid[_account] = paid[_account] + balanceDue;\n\n            bool success = _safeTransferETH(_account, balanceDue);\n            require(success, \"Transfer failed\");\n\n            emit AuctionProceedsWithdrawn(_account, balanceDue);\n        }\n    }\n\n    // ============ INTERNAL FUNCTIONS ============\n\n    function _requestCreateAuction() private {\n        // Trigger of chain oracle to pick and release next auction.\n        emit RequestCreateAuction();\n    }\n\n    function _createAuction(uint256 _tokenId) internal {\n        auctionId.increment();\n        activeAuctions.increment();\n        uint256 currentAuctionId = auctionId.current();\n        // Create new auction but don't start it.\n        auctions[currentAuctionId] = Auction({\n            auctionId: currentAuctionId,\n            tokenId: _tokenId,\n            amount: 0,\n            startTime: 0,\n            endTime: 0,\n            reservePrice: reservePrice,\n            bidder: payable(address(0)),\n            auctioneer: etsAccessControls.getPlatformAddress(),\n            settled: false\n        });\n\n        // Add the auction Id to list of auctions for this token.\n        uint256[] storage tokenAuctionIds = auctionsByTokenId[_tokenId];\n        tokenAuctionIds.push(currentAuctionId);\n\n        emit AuctionCreated(currentAuctionId, _tokenId, tokenAuctionIds.length);\n        //emit AuctionCreated(_tokenId);\n    }\n\n    function _settleAuction(uint256 _auctionId) internal {\n        require(_auctionExists(_auctionId), \"Auction not found\");\n        Auction memory auction = getAuction(_auctionId);\n        require(!(auction.settled), \"Auction already settled\");\n        require(auction.startTime != 0, \"Auction has not begun\");\n        require(block.timestamp >= auction.endTime, \"Auction has not ended\");\n\n        auctions[_auctionId].settled = true;\n        activeAuctions.decrement();\n        etsToken.transferFrom(etsAccessControls.getPlatformAddress(), auction.bidder, auction.tokenId);\n        _processAuctionRevenue(auction.tokenId, auction.amount);\n        emit AuctionSettled(_auctionId);\n    }\n\n    // @dev Internal function to divide up auction revenue and accrue it to ETS participants.\n    function _processAuctionRevenue(uint256 _tokenId, uint256 _amount) private {\n        // Distribute proceeds to actors.\n        IETSToken.Tag memory ctag = etsToken.getTagById(_tokenId);\n        address platform = etsAccessControls.getPlatformAddress();\n\n        uint256 relayerProceeds = (_amount * relayerPercentage) / MODULO;\n        uint256 creatorProceeds = (_amount * creatorPercentage) / MODULO;\n        uint256 platformProceeds = _amount - (relayerProceeds + creatorProceeds);\n\n        accrued[ctag.relayer] = accrued[ctag.relayer] + relayerProceeds;\n        accrued[ctag.creator] = accrued[ctag.creator] + creatorProceeds;\n        accrued[platform] = accrued[platform] + platformProceeds;\n    }\n\n    /**\n     * @dev Retrieves an auction given an auction ID.\n     * @param _auctionId The ID of auction.\n     * @return Auction object. Returns an empty object if no auction exists\n     *         so must perform additional checks downstream.\n     */\n    function _getAuction(uint256 _auctionId) internal view returns (Auction memory) {\n        return auctions[_auctionId];\n    }\n\n    function _safeTransferETHWithFallback(address to, uint256 amount) internal {\n        if (!_safeTransferETH(to, amount)) {\n            IWMATIC(wmatic).deposit{ value: amount }();\n            IERC20Upgradeable(wmatic).transfer(to, amount);\n        }\n    }\n\n    function _safeTransferETH(address to, uint256 value) internal returns (bool) {\n        (bool success, ) = to.call{ value: value, gas: 30_000 }(new bytes(0));\n        return success;\n    }\n\n    // Return true if tag has had an auction released in any state.\n    function _auctionExists(uint256 _auctionId) internal view returns (bool) {\n        return (auctions[_auctionId].auctionId != 0 && auctions[_auctionId].auctionId == _auctionId);\n    }\n\n    // ============ PUBLIC VIEW FUNCTIONS ============\n\n    function auctionExists(uint256 _auctionId) public view returns (bool) {\n        return _auctionExists(_auctionId);\n    }\n\n    function auctionExistsForTokenId(uint256 _tokenId) public view returns (bool) {\n        return (auctionsByTokenId[_tokenId].length > 0);\n    }\n\n    function auctionEnded(uint256 _auctionId) public view returns (bool) {\n        return (auctions[_auctionId].endTime < block.timestamp);\n    }\n\n    function auctionSettled(uint256 _auctionId) public view returns (bool) {\n        return (_auctionExists(_auctionId) && auctions[_auctionId].settled);\n    }\n\n    function getAuction(uint256 _auctionId) public view returns (Auction memory) {\n        return _getAuction(_auctionId);\n    }\n\n    function getAuctionForTokenId(uint256 _tokenId) public view returns (Auction memory) {\n        require(auctionExistsForTokenId(_tokenId), \"No auctions for tokenId\");\n        uint256[] memory tokenAuctionIds = auctionsByTokenId[_tokenId];\n        // Return last auction for token.\n        return auctions[tokenAuctionIds[tokenAuctionIds.length - 1]];\n    }\n\n    function getAuctionCountForTokenId(uint256 _tokenId) public view returns (uint256) {\n        return auctionsByTokenId[_tokenId].length;\n    }\n\n    function getActiveCount() public view returns (uint256) {\n        return activeAuctions.current();\n    }\n\n    function getTotalCount() public view returns (uint256) {\n        return auctionId.current();\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function totalDue(address _account) public view returns (uint256 _due) {\n        return accrued[_account] - paid[_account];\n    }\n\n    /* solhint-disable */\n    receive() external payable {}\n\n    fallback() external payable {}\n    /* solhint-enable */\n}\n"
    },
    "contracts/ETSEnrichTarget.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title ETSEnrichTarget\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  ███████╗████████╗███████╗\n *  ██╔════╝╚══██╔══╝██╔════╝\n *  █████╗     ██║   ███████╗\n *  ██╔══╝     ██║   ╚════██║\n *  ███████╗   ██║   ███████║\n *  ╚══════╝   ╚═╝   ╚══════╝\n *\n * @notice Contract that handles the enrichment of Target metadata using off-chain APIs.\n *\n * In order to keep the on-chain recording of new Target records lightweight and inexpensive,\n * the createTarget() function (ETSTarget.sol) requires only a URI string (targetURI).\n *\n * To augment this, we are developing a hybrid onchain/off-chain Enrich Target flow for the purpose of\n * collecting additional metadata about a Target and saving it back on-chain.\n *\n * The flow begins with the requestEnrichTarget() function (see below) which takes a targetId as an\n * argument. If the Target exists, the function emits the targetId via the RequestEnrichTarget event.\n *\n * An OpenZeppelin Defender Sentinel is listening for this event, and when detected, passes the\n * targetId to an ETS off-chain service we call the Enrich Target API, which extracts the Target URI,\n * collects metadata about the URI and saves it in json format to IPFS. The IPFS entpoint is posted\n * back on-chain via fulfillEnrichTarget() thus updating the Target data struct.\n *\n * Future implementation should utilize ChainLink in place of OpenZeppelin for better decentralization.\n */\n\npragma solidity ^0.8.10;\n\nimport { IETSTarget } from \"./interfaces/IETSTarget.sol\";\nimport { IETSEnrichTarget } from \"./interfaces/IETSEnrichTarget.sol\";\nimport { IETSAccessControls } from \"./interfaces/IETSAccessControls.sol\";\nimport { ContextUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\ncontract ETSEnrichTarget is IETSEnrichTarget, Initializable, ContextUpgradeable, UUPSUpgradeable {\n    /// @dev ETS access controls smart contract.\n    IETSAccessControls public etsAccessControls;\n\n    /// @dev ETS access controls smart contract.\n    IETSTarget public etsTarget;\n\n    // Public constants\n\n    string public constant NAME = \"ETSEnrichTarget\";\n\n    // Modifiers\n\n    modifier onlyAdmin() {\n        require(etsAccessControls.isAdmin(_msgSender()), \"Access denied\");\n        _;\n    }\n\n    // ============ UUPS INTERFACE ============\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(IETSAccessControls _etsAccessControls, IETSTarget _etsTarget) public initializer {\n        // Initialize access controls & ETS\n        etsAccessControls = _etsAccessControls;\n        etsTarget = _etsTarget;\n    }\n\n    // solhint-disable-next-line\n    function _authorizeUpgrade(address) internal override onlyAdmin {}\n\n    // ============ PUBLIC INTERFACE ============\n\n    /// @inheritdoc IETSEnrichTarget\n    function requestEnrichTarget(uint256 _targetId) public {\n        require(etsTarget.targetExistsById(_targetId) == true, \"Invalid target\");\n        // require(!etsTarget.isTargetEnsured(_targetId), \"Already ensured\");\n        emit RequestEnrichTarget(_targetId);\n    }\n\n    // ============ OWNER INTERFACE ============\n\n    /// @inheritdoc IETSEnrichTarget\n    function fulfillEnrichTarget(uint256 _targetId, string calldata _ipfsHash, uint256 _httpStatus) public {\n        require(etsAccessControls.getPlatformAddress() == msg.sender, \"only platform may enrich target\");\n        IETSTarget.Target memory target = etsTarget.getTargetById(_targetId);\n        etsTarget.updateTarget(_targetId, target.targetURI, block.timestamp, _httpStatus, _ipfsHash);\n    }\n}\n"
    },
    "contracts/ETSRelayerFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title ETS Relayer Factory\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  ███████╗████████╗███████╗\n *  ██╔════╝╚══██╔══╝██╔════╝\n *  █████╗     ██║   ███████╗\n *  ██╔══╝     ██║   ╚════██║\n *  ███████╗   ██║   ███████║\n *  ╚══════╝   ╚═╝   ╚══════╝\n *\n * @notice Factory contract for deploying upgradeable beacon proxy contract instances.\n * @dev see ETSRelayerBeacon.sol & ETSRelayerV1.sol\n */\n\npragma solidity ^0.8.10;\n\nimport { IETS } from \"./interfaces/IETS.sol\";\nimport { IETSTarget } from \"./interfaces/IETSTarget.sol\";\nimport { IETSToken } from \"./interfaces/IETSToken.sol\";\nimport { IETSAccessControls } from \"./interfaces/IETSAccessControls.sol\";\nimport { ETSRelayerBeacon } from \"./relayers/ETSRelayerBeacon.sol\";\nimport { ETSRelayerV1 } from \"./relayers/ETSRelayerV1.sol\";\n\nimport { Context } from \"@openzeppelin/contracts/utils/Context.sol\";\nimport { BeaconProxy } from \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\n\ncontract ETSRelayerFactory is Context {\n    mapping(uint256 => address) private vaults;\n\n    ETSRelayerBeacon immutable etsRelayerBeacon;\n\n    /// @dev ETS access controls contract.\n    IETSAccessControls public etsAccessControls;\n\n    /// @dev Address and interface for ETS Core.\n    IETS public ets;\n\n    /// @dev Address and interface for ETS Token\n    IETSToken public etsToken;\n\n    /// @dev Address and interface for ETS Target.\n    IETSTarget public etsTarget;\n\n    // Modifiers\n\n    modifier onlyValidName(string calldata _name) {\n        require(!etsAccessControls.isRelayerByName(_name), \"Relayer name exists\");\n        bytes memory nameBytes = bytes(_name);\n        require(nameBytes.length >= 2, \"Relayer name too short\");\n        require(nameBytes.length <= 32, \"Relayer name too long\");\n        _;\n    }\n\n    /// Public constants\n\n    string public constant NAME = \"ETS Relayer Factory V1\";\n\n    constructor(\n        address _etsRelayerLogic,\n        IETSAccessControls _etsAccessControls,\n        IETS _ets,\n        IETSToken _etsToken,\n        IETSTarget _etsTarget\n    ) {\n        etsRelayerBeacon = new ETSRelayerBeacon(_etsRelayerLogic);\n        etsAccessControls = _etsAccessControls;\n        ets = _ets;\n        etsToken = _etsToken;\n        etsTarget = _etsTarget;\n    }\n\n    function addRelayer(string calldata _relayerName) external onlyValidName(_relayerName) returns (address relayer) {\n        require(\n            etsToken.balanceOf(_msgSender()) > 0 || etsAccessControls.isRelayerAdmin(_msgSender()),\n            \"Must own CTAG\"\n        );\n        // TODO: Uncomment to restrict to single relayer\n        //require(!etsAccessControls.isRelayerByOwner(_msgSender()), \"Sender owns existing relayer\");\n        BeaconProxy relayerProxy = new BeaconProxy(\n            address(etsRelayerBeacon),\n            abi.encodeWithSelector(\n                ETSRelayerV1(payable(address(0))).initialize.selector,\n                _relayerName,\n                ets,\n                etsToken,\n                etsTarget,\n                etsAccessControls,\n                payable(_msgSender()),\n                payable(_msgSender())\n            )\n        );\n\n        etsAccessControls.registerRelayer(address(relayerProxy), _relayerName, _msgSender());\n        return address(relayerProxy);\n    }\n\n    function getImplementation() public view returns (address) {\n        return etsRelayerBeacon.implementation();\n    }\n\n    function getBeacon() public view returns (address) {\n        return address(etsRelayerBeacon);\n    }\n}\n"
    },
    "contracts/ETSTarget.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title IETSTarget\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  ███████╗████████╗███████╗\n *  ██╔════╝╚══██╔══╝██╔════╝\n *  █████╗     ██║   ███████╗\n *  ██╔══╝     ██║   ╚════██║\n *  ███████╗   ██║   ███████║\n *  ╚══════╝   ╚═╝   ╚══════╝\n *\n * @notice This is core ETSTarget.sol contract for creating Target records in ETS. It includes both public\n * and administration functions.\n *\n * In ETS, a \"Target\" is our data structure, stored onchain, that references/points to a URI. Target records\n * are identified in ETS by their Id (targetId) which is a unsigned integer computed from the URI string.\n * Target Ids are combined with CTAG Ids by ETS core (ETS.sol) to form \"Tagging Records\".\n *\n * For context, from Wikipedia, URI is short for Uniform Resource Identifier and is a unique sequence of\n * characters that identifies a logical or physical resource used by web technologies. URIs may be used to\n * identify anything, including real-world objects, such as people and places, concepts, or information\n * resources such as web pages and books.\n *\n * For our purposes, as much as possible, we are restricting our interpretation of URIs to the more technical\n * parameters defined by the IETF in [RFC3986](https://www.rfc-editor.org/rfc/rfc3986). For newer protocols, such\n * as blockchains, we will lean on newer emerging URI standards such as the [Blink](https://w3c-ccg.github.io/blockchain-links)\n * and [BIP-122](https://github.com/bitcoin/bips/blob/master/bip-0122.mediawiki)\n *\n * One the thing to keep in mind with URIs & ETS Targets is that differently shaped URIs can sometimes point to the same\n * resource. The effect of that is that different Target IDs in ETS can similarly point to the same resource.\n */\n\npragma solidity ^0.8.10;\n\nimport { IETSTarget } from \"./interfaces/IETSTarget.sol\";\nimport { IETSEnrichTarget } from \"./interfaces/IETSEnrichTarget.sol\";\nimport { IETSAccessControls } from \"./interfaces/IETSAccessControls.sol\";\nimport { StringHelpers } from \"./utils/StringHelpers.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\ncontract ETSTarget is IETSTarget, UUPSUpgradeable, StringHelpers {\n    IETSAccessControls public etsAccessControls;\n\n    IETSEnrichTarget public etsEnrichTarget;\n\n    // Public constants\n\n    string public constant NAME = \"ETSTarget\";\n\n    /// @dev Map of targetId to Target struct.\n    mapping(uint256 => Target) public targets;\n\n    // Modifiers\n\n    modifier onlyAdmin() {\n        require(etsAccessControls.isAdmin(msg.sender), \"Access denied\");\n        _;\n    }\n\n    // ============ UUPS INTERFACE ============\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _etsAccessControls) public initializer {\n        etsAccessControls = IETSAccessControls(_etsAccessControls);\n    }\n\n    // solhint-disable-next-line\n    function _authorizeUpgrade(address) internal override onlyAdmin {}\n\n    // ============ OWNER INTERFACE ============\n\n    /**\n     * @notice Sets ETSAccessControls on the ETSTarget contract so functions can be\n     * restricted to ETS platform only. Note Caller of this function must be deployer\n     * or pre-set as admin of new contract.\n     *\n     * @param _accessControls Address of ETSAccessControls contract.\n     */\n    function setAccessControls(IETSAccessControls _accessControls) public onlyAdmin {\n        require(address(_accessControls) != address(0), \"Address cannot be zero\");\n        require(_accessControls.isAdmin(msg.sender), \"Caller not admin in new contract\");\n        etsAccessControls = _accessControls;\n        emit AccessControlsSet(address(etsAccessControls));\n    }\n\n    /// @inheritdoc IETSTarget\n    function setEnrichTarget(address _etsEnrichTarget) public onlyAdmin {\n        require(address(_etsEnrichTarget) != address(0), \"Bad address\");\n        etsEnrichTarget = IETSEnrichTarget(_etsEnrichTarget);\n        emit EnrichTargetSet(_etsEnrichTarget);\n    }\n\n    // ============ PUBLIC INTERFACE ============\n\n    /// @inheritdoc IETSTarget\n    function getOrCreateTargetId(string memory _targetURI) public returns (uint256) {\n        uint256 _targetId = computeTargetId(_targetURI);\n        if (bytes(targets[_targetId].targetURI).length > 0) {\n            return _targetId;\n        }\n\n        return createTarget(_targetURI);\n    }\n\n    /// @inheritdoc IETSTarget\n    function createTarget(string memory _targetURI) public returns (uint256 targetId) {\n        require(!targetExistsByURI(_targetURI), \"target id exists\");\n        require(bytes(_targetURI).length > 0, \"empty target\");\n\n        uint256 _targetId = computeTargetId(_targetURI);\n        targets[_targetId] = Target({\n            targetURI: _targetURI,\n            createdBy: msg.sender,\n            enriched: 0,\n            httpStatus: 0,\n            ipfsHash: \"\"\n        });\n        emit TargetCreated(_targetId);\n        return _targetId;\n    }\n\n    /// @inheritdoc IETSTarget\n    function updateTarget(\n        uint256 _targetId,\n        string calldata _targetURI,\n        uint256 _enriched,\n        uint256 _httpStatus,\n        string calldata _ipfsHash\n    ) external returns (bool success) {\n        require(msg.sender == address(etsEnrichTarget), \"Access denied\");\n        targets[_targetId].targetURI = _targetURI;\n        targets[_targetId].enriched = _enriched;\n        targets[_targetId].httpStatus = _httpStatus;\n        targets[_targetId].ipfsHash = _ipfsHash;\n\n        emit TargetUpdated(_targetId);\n        return true;\n    }\n\n    // ============ PUBLIC VIEW FUNCTIONS ============\n\n    /// @inheritdoc IETSTarget\n    function computeTargetId(string memory _targetURI) public pure returns (uint256) {\n        // ? Should we lowercase\n        bytes32 targetId = keccak256(bytes(_targetURI));\n        return uint256(targetId);\n    }\n\n    /// @inheritdoc IETSTarget\n    function targetExistsByURI(string memory _targetURI) public view returns (bool) {\n        uint256 targetId = computeTargetId(_targetURI);\n        return targetExistsById(targetId);\n    }\n\n    /// @inheritdoc IETSTarget\n    function targetExistsById(uint256 _targetId) public view returns (bool) {\n        return bytes(targets[_targetId].targetURI).length > 0 ? true : false;\n    }\n\n    /// @inheritdoc IETSTarget\n    function getTargetByURI(string memory _targetURI) public view returns (Target memory) {\n        uint256 targetId = computeTargetId(_targetURI);\n        return getTargetById(targetId);\n    }\n\n    /// @inheritdoc IETSTarget\n    function getTargetById(uint256 _targetId) public view returns (Target memory) {\n        return targets[_targetId];\n    }\n}\n"
    },
    "contracts/ETSToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title ETSToken\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  ███████╗████████╗███████╗\n *  ██╔════╝╚══██╔══╝██╔════╝\n *  █████╗     ██║   ███████╗\n *  ██╔══╝     ██║   ╚════██║\n *  ███████╗   ██║   ███████║\n *  ╚══════╝   ╚═╝   ╚══════╝\n *\n * @notice This is the core ETSToken.sol contract that governs the creation & management of\n * Ethereum Tag Service composable tags (CTAGs).\n *\n * CTAGs are ERC-721 non-fungible tokens that store a single tag string and origin attribution data\n * including a \"Relayer\" address and a \"Creator\" address. The tag string must conform to a few simple\n * validation rules.\n *\n * CTAGs are identified in ETS by their Id (tagId) which is an unsigned integer computed from the lowercased\n * tag \"display\" string. Given this, only one CTAG exists for a tag string regardless of its case. For\n * example, #Punks, #punks and #PUNKS all resolve to the same CTAG.\n *\n * CTAG Ids are combined with Target Ids (see ETSTarget.sol) by ETS core (ETS.sol) to form \"Tagging Records\".\n * See ETS.sol for more details on Tagging Records.\n */\n\npragma solidity ^0.8.10;\n\nimport { IETS } from \"./interfaces/IETS.sol\";\nimport { IETSToken } from \"./interfaces/IETSToken.sol\";\nimport { IETSAccessControls } from \"./interfaces/IETSAccessControls.sol\";\nimport { StringHelpers } from \"./utils/StringHelpers.sol\";\nimport { ERC721PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721PausableUpgradeable.sol\";\nimport { ERC721BurnableUpgradeable, ERC721Upgradeable, IERC165Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\ncontract ETSToken is\n    ERC721PausableUpgradeable,\n    ERC721BurnableUpgradeable,\n    IETSToken,\n    ReentrancyGuardUpgradeable,\n    UUPSUpgradeable,\n    StringHelpers\n{\n    IETS public ets;\n    IETSAccessControls public etsAccessControls;\n\n    // Public constants\n    string public constant NAME = \"CTAG Token\";\n\n    // Public variables\n    uint256 public tagMinStringLength;\n    uint256 public tagMaxStringLength;\n    uint256 public ownershipTermLength;\n\n    /// @dev Map of CTAG id to CTAG record.\n    mapping(uint256 => Tag) public tokenIdToTag;\n\n    /// @dev Mapping of tokenId to last renewal.\n    mapping(uint256 => uint256) public tokenIdToLastRenewed;\n\n    /// @notice Defines whether a tag has been set up as premium\n    mapping(string => bool) public isTagPremium;\n\n    /// Modifiers\n    modifier onlyETSCore() {\n        require(_msgSender() == address(ets), \"Caller is not ETS core\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(etsAccessControls.isAdmin(_msgSender()), \"Access denied\");\n        _;\n    }\n\n    modifier onlyRelayer() {\n        require(etsAccessControls.isRelayer(_msgSender()), \"Caller is not relayer\");\n        _;\n    }\n\n    // ============ UUPS INTERFACE ============\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        IETSAccessControls _etsAccessControls,\n        uint256 _tagMinStringLength,\n        uint256 _tagMaxStringLength,\n        uint256 _ownershipTermLength\n    ) public initializer {\n        __ERC721_init(\"Ethereum Tag Service\", \"CTAG\");\n        __ERC721Pausable_init();\n        __ERC721Burnable_init();\n        __ReentrancyGuard_init();\n\n        // Initialize ETSToken settings using public\n        // functions so our subgraph can capture them.\n        // To call them requires etsAccessControls being\n        // set so we set that manually first.\n        etsAccessControls = _etsAccessControls;\n        setTagMinStringLength(_tagMinStringLength);\n        setTagMaxStringLength(_tagMaxStringLength);\n        setOwnershipTermLength(_ownershipTermLength);\n    }\n\n    // solhint-disable-next-line\n    function _authorizeUpgrade(address) internal override onlyAdmin {}\n\n    // ============ OWNER INTERFACE ============\n\n    /**\n     * @notice Sets ETS core on the ETSToken contract so functions can be\n     * restricted to ETS platform only.\n     *\n     * @param _ets Address of ETS contract.\n     */\n    function setETSCore(IETS _ets) public onlyAdmin {\n        require(address(_ets) != address(0), \"Address cannot be zero\");\n        ets = _ets;\n        emit ETSCoreSet(address(ets));\n    }\n\n    /**\n     * @notice Sets ETSAccessControls on the ETSToken contract function calls can be\n     * restricted to ETS platform only. Note: Caller of this function must be deployer\n     * or pre-set as admin of new contract.\n     *\n     * @param _accessControls Address of ETSAccessControls contract.\n     */\n    function setAccessControls(IETSAccessControls _accessControls) public onlyAdmin {\n        require(address(_accessControls) != address(0), \"Address cannot be zero\");\n        require(_accessControls.isAdmin(_msgSender()), \"Caller not admin in new contract\");\n        etsAccessControls = _accessControls;\n        emit AccessControlsSet(address(etsAccessControls));\n    }\n\n    /**\n     * @notice Pauses ETSToken contract.\n     */\n    function pause() public onlyAdmin whenNotPaused {\n        _pause();\n    }\n\n    /**\n     * @notice Unpauses ETSToken contract.\n     */\n    function unPause() public onlyAdmin whenPaused {\n        _unpause();\n    }\n\n    /// @inheritdoc ERC721BurnableUpgradeable\n    function burn(uint256 tokenId) public override onlyAdmin {\n        _burn(tokenId);\n    }\n\n    /// @inheritdoc IETSToken\n    function setTagMaxStringLength(uint256 _tagMaxStringLength) public onlyAdmin {\n        tagMaxStringLength = _tagMaxStringLength;\n        emit TagMaxStringLengthSet(_tagMaxStringLength);\n    }\n\n    /// @inheritdoc IETSToken\n    function setTagMinStringLength(uint256 _tagMinStringLength) public onlyAdmin {\n        tagMinStringLength = _tagMinStringLength;\n        emit TagMinStringLengthSet(_tagMinStringLength);\n    }\n\n    /// @inheritdoc IETSToken\n    function setOwnershipTermLength(uint256 _ownershipTermLength) public onlyAdmin {\n        ownershipTermLength = _ownershipTermLength;\n        emit OwnershipTermLengthSet(_ownershipTermLength);\n    }\n\n    /// @inheritdoc IETSToken\n    function preSetPremiumTags(string[] calldata _tags, bool _enabled) public onlyAdmin {\n        require(_tags.length > 0, \"Empty array\");\n        for (uint256 i; i < _tags.length; ++i) {\n            string memory tag = __lower(_tags[i]);\n            isTagPremium[tag] = _enabled;\n            emit PremiumTagPreSet(tag, _enabled);\n        }\n    }\n\n    /// @inheritdoc IETSToken\n    function setPremiumFlag(uint256[] calldata _tokenIds, bool _isPremium) public onlyAdmin {\n        require(_tokenIds.length > 0, \"Empty array\");\n        for (uint256 i; i < _tokenIds.length; ++i) {\n            uint256 tokenId = _tokenIds[i];\n            require(ownerOf(tokenId) == getPlatformAddress(), \"Not owned by platform\");\n            tokenIdToTag[tokenId].premium = _isPremium;\n            emit PremiumFlagSet(tokenId, _isPremium);\n        }\n    }\n\n    /// @inheritdoc IETSToken\n    function setReservedFlag(uint256[] calldata _tokenIds, bool _reserved) public onlyAdmin {\n        require(_tokenIds.length > 0, \"Empty array\");\n        for (uint256 i; i < _tokenIds.length; ++i) {\n            uint256 tokenId = _tokenIds[i];\n            require(ownerOf(tokenId) == getPlatformAddress(), \"Token not owned by platform\");\n            tokenIdToTag[tokenId].reserved = _reserved;\n            emit ReservedFlagSet(tokenId, _reserved);\n        }\n    }\n\n    // ============ PUBLIC INTERFACE ============\n\n    function getOrCreateTag(\n        string calldata _tag,\n        address payable _relayer,\n        address payable _creator\n    ) public payable returns (Tag memory tag) {\n        uint256 tokenId = computeTagId(_tag);\n        if (!tagExistsById(tokenId)) {\n            tokenId = createTag(_tag, _relayer, _creator);\n        }\n        return tokenIdToTag[tokenId];\n    }\n\n    /// @inheritdoc IETSToken\n    function getOrCreateTagId(\n        string calldata _tag,\n        address payable _relayer,\n        address payable _creator\n    ) public payable returns (uint256 tokenId) {\n        uint256 _tokenId = computeTagId(_tag);\n        if (!tagExistsById(_tokenId)) {\n            _tokenId = createTag(_tag, _relayer, _creator);\n        }\n        return _tokenId;\n    }\n\n    /// @inheritdoc IETSToken\n    function createTag(\n        string calldata _tag,\n        address payable _relayer,\n        address payable _creator\n    ) public payable nonReentrant onlyETSCore returns (uint256 _tokenId) {\n        // Perform basic tag string validation.\n        uint256 tagId = _assertTagIsValid(_tag);\n\n        // mint the token, transferring it to the platform.\n        _safeMint(getPlatformAddress(), tagId);\n\n        // Store CTAG data in state.\n        tokenIdToTag[tagId] = Tag({\n            display: _tag,\n            relayer: _relayer,\n            creator: _creator,\n            premium: isTagPremium[__lower(_tag)],\n            reserved: isTagPremium[__lower(_tag)]\n        });\n\n        return tagId;\n    }\n\n    /// @inheritdoc IETSToken\n    function renewTag(uint256 _tokenId) public {\n        require(_exists(_tokenId), \"ETS: CTAG not found\");\n\n        if (ownerOf(_tokenId) == getPlatformAddress()) {\n            _setLastRenewed(_tokenId, 0);\n        } else {\n            _setLastRenewed(_tokenId, block.timestamp);\n        }\n    }\n\n    /// @inheritdoc IETSToken\n    function recycleTag(uint256 _tokenId) public {\n        require(_exists(_tokenId), \"ETS: CTAG not found\");\n        require(ownerOf(_tokenId) != getPlatformAddress(), \"Tag owned by platform\");\n        require(tagOwnershipTermExpired(_tokenId), \"recycling not available\");\n\n        _transfer(ownerOf(_tokenId), getPlatformAddress(), _tokenId);\n        emit TagRecycled(_tokenId, _msgSender());\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(ERC721Upgradeable, IERC165Upgradeable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    // ============ PUBLIC VIEW FUNCTIONS ============\n\n    /// @inheritdoc IETSToken\n    function computeTagId(string memory _tag) public pure returns (uint256) {\n        string memory _machineName = __lower(_tag);\n        return uint256(keccak256(bytes(_machineName)));\n    }\n\n    /// @inheritdoc IETSToken\n    function tagExistsByString(string calldata _tag) public view returns (bool) {\n        return _exists(computeTagId(_tag));\n    }\n\n    /// @inheritdoc IETSToken\n    function tagExistsById(uint256 _tokenId) public view returns (bool) {\n        return _exists(_tokenId);\n    }\n\n    /// @inheritdoc IETSToken\n    function tagOwnershipTermExpired(uint256 _tokenId) public view returns (bool) {\n        return (getLastRenewed(_tokenId) + getOwnershipTermLength() < block.timestamp);\n    }\n\n    /// @inheritdoc IETSToken\n    function getTagByString(string calldata _tag) public view returns (Tag memory) {\n        return getTagById(computeTagId(_tag));\n    }\n\n    /// @inheritdoc IETSToken\n    function getTagById(uint256 _tokenId) public view returns (Tag memory) {\n        return tokenIdToTag[_tokenId];\n    }\n\n    /// @inheritdoc IETSToken\n    function getOwnershipTermLength() public view returns (uint256) {\n        return ownershipTermLength;\n    }\n\n    /// @inheritdoc IETSToken\n    function getLastRenewed(uint256 _tokenId) public view returns (uint256) {\n        return tokenIdToLastRenewed[_tokenId];\n    }\n\n    /// @inheritdoc IETSToken\n    function getPlatformAddress() public view returns (address payable) {\n        return etsAccessControls.getPlatformAddress();\n    }\n\n    /// @inheritdoc IETSToken\n    function getCreatorAddress(uint256 _tokenId) public view returns (address) {\n        return tokenIdToTag[_tokenId].creator;\n    }\n\n    // ============ INTERNAL FUNCTIONS ============\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal override(ERC721PausableUpgradeable, ERC721Upgradeable) whenNotPaused {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n        require(!paused(), \"Contract paused\");\n    }\n\n    /// @dev See {ERC721-_afterTokenTransfer}. Contract must not be paused.\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 batchSize\n    ) internal virtual override(ERC721Upgradeable) {\n        super._afterTokenTransfer(from, to, tokenId, batchSize);\n\n        if (to != address(0)) {\n            // Reset token ownership term.\n            if (to == getPlatformAddress()) {\n                _setLastRenewed(tokenId, 0);\n            } else {\n                _setLastRenewed(tokenId, block.timestamp);\n            }\n        }\n\n        // If from address is not black hole or platform, and balance is going zero pause their relayer.\n        if (from != address(0) && from != getPlatformAddress() && balanceOf(from) == 0) {\n            etsAccessControls.pauseRelayerByOwnerAddress(from);\n        }\n    }\n\n    /**\n     * @dev Private method used for validating a CTAG string before minting.\n     *\n     * A series of assertions are performed reverting the transaction for any validation violations.\n     *\n     * @param _tag Proposed tag string.\n     */\n    function _assertTagIsValid(string memory _tag) private view returns (uint256 _tagId) {\n        // generate token ID from machine name\n        uint256 tagId = computeTagId(_tag);\n\n        require(!_exists(tagId), \"ERC721: token already minted\");\n\n        bytes memory tagStringBytes = bytes(_tag);\n        require(\n            tagStringBytes.length >= tagMinStringLength && tagStringBytes.length <= tagMaxStringLength,\n            \"Invalid tag format\"\n        );\n\n        require(tagStringBytes[0] == 0x23, \"Tag must start with #\");\n\n        // start from first char after #\n        for (uint256 i = 1; i < tagStringBytes.length; i++) {\n            bytes1 char = tagStringBytes[i];\n            require(char != 0x20, \"Spaces in tag\");\n            require(char != 0x23, \"Tag contains prefix\");\n        }\n\n        return tagId;\n    }\n\n    function _setLastRenewed(uint256 _tokenId, uint256 _timestamp) internal {\n        tokenIdToLastRenewed[_tokenId] = _timestamp;\n        emit TagRenewed(_tokenId, msg.sender);\n    }\n}\n"
    },
    "contracts/interfaces/IETS.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title IETS\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  ███████╗████████╗███████╗\n *  ██╔════╝╚══██╔══╝██╔════╝\n *  █████╗     ██║   ███████╗\n *  ██╔══╝     ██║   ╚════██║\n *  ███████╗   ██║   ███████║`\n *  ╚══════╝   ╚═╝   ╚══════╝\n *\n * @notice This is the interface for the ETS.sol core contract that records ETS TaggingRecords to the blockchain.\n */\n\npragma solidity ^0.8.10;\n\ninterface IETS {\n    /**\n     * @notice Data structure for raw client input data.\n     *\n     * @param targetURI Unique resource identifier string, eg. \"https://google.com\"\n     * @param tagStrings Array of hashtag strings, eg. [\"#Love, \"#Blue\"]\n     * @param recordType Arbitrary identifier for type of tagging record, eg. \"Bookmark\"\n     */\n    struct TaggingRecordRawInput {\n        string targetURI;\n        string[] tagStrings;\n        string recordType;\n    }\n\n    /**\n     * @notice Data structure for an Ethereum Tag Service \"tagging record\".\n     *\n     * The TaggingRecord is the fundamental data structure of ETS and reflects \"who tagged what, where and why\".\n     *\n     * Every Tagging record has a unique Id computed from the hashed composite of targetId, recordType, tagger and\n     * relayer addresses cast as a uint256. see computeTaggingRecordId()\n     *\n     * Given this design, a tagger who tags the same URI with the same tags and recordType via two different relayers\n     * would produce two TaggingRecords in ETS.\n     *\n     * @param tagIds Ids of CTAG token(s).\n     * @param targetId Id of target being tagged.\n     * @param recordType Arbitrary identifier for type of tagging record.\n     * @param relayer Address of Relayer contract that wrote tagging record.\n     * @param tagger Address of wallet that initiated tagging record via relayer.\n     */\n    struct TaggingRecord {\n        uint256[] tagIds;\n        uint256 targetId;\n        string recordType;\n        address relayer;\n        address tagger;\n    }\n\n    /**\n     * @dev Action types available for tags in a tagging record.\n     *\n     * 0 - APPEND Add tags to a tagging record.\n     * 1 - REPLACE Replace (overwrite) tags in a tagging record.\n     * 2 - REMOVE Remove tags in a tagging record.\n     */\n    enum TaggingAction {\n        APPEND,\n        REPLACE,\n        REMOVE\n    }\n\n    /**\n     * @dev emitted when the ETS Access Controls is set.\n     *\n     * @param newAccessControls contract address access controls is set to.\n     */\n    event AccessControlsSet(address newAccessControls);\n\n    /**\n     * @dev emitted when ETS tagging fee is set.\n     *\n     * @param newTaggingFee new tagging fee.\n     */\n    event TaggingFeeSet(uint256 newTaggingFee);\n\n    /**\n     * @dev emitted when participant distribution percentages are set.\n     *\n     * @param platformPercentage percentage of tagging fee allocated to ETS.\n     * @param relayerPercentage percentage of tagging fee allocated to relayer of record for CTAG being used in tagging record.\n     */\n    event PercentagesSet(uint256 platformPercentage, uint256 relayerPercentage);\n\n    /**\n     * @dev emitted when a new tagging record is recorded within ETS.\n     *\n     * @param taggingRecordId Unique identifier of tagging record.\n     */\n    event TaggingRecordCreated(uint256 taggingRecordId);\n\n    /**\n     * @dev emitted when a tagging record is updated.\n     *\n     * @param taggingRecordId tagging record being updated.\n     * @param action Type of update applied as TaggingAction enum.\n     */\n    event TaggingRecordUpdated(uint256 taggingRecordId, TaggingAction action);\n\n    /**\n     * @dev emitted when ETS participant draws down funds accrued to their contract or wallet.\n     *\n     * @param who contract or wallet address being drawn down.\n     * @param amount amount being drawn down.\n     */\n    event FundsWithdrawn(address indexed who, uint256 amount);\n\n    // ============ PUBLIC INTERFACE ============\n\n    /**\n     * @notice Create a new tagging record.\n     *\n     * Requirements:\n     *\n     *   - Caller must be relayer contract.\n     *   - CTAG(s) and TargetId must exist.\n     *\n     * @param _tagIds Array of CTAG token Ids.\n     * @param _targetId targetId of the URI being tagged. See ETSTarget.sol\n     * @param _recordType Arbitrary identifier for type of tagging record.\n     * @param _tagger Address calling Relayer contract to create tagging record.\n     */\n    function createTaggingRecord(\n        uint256[] memory _tagIds,\n        uint256 _targetId,\n        string calldata _recordType,\n        address _tagger\n    ) external payable;\n\n    /**\n     * @notice Get or create CTAG token from tag string.\n     *\n     * Combo function that accepts a tag string and returns corresponding CTAG token Id if it exists,\n     * or if it doesn't exist, creates a new CTAG and then returns corresponding Id.\n     *\n     * Only ETS Relayer contracts may call this function.\n     *\n     * @param _tag Tag string.\n     * @param _creator Address credited with creating CTAG.\n     * @return tokenId Id of CTAG token.\n     */\n    function getOrCreateTagId(\n        string calldata _tag,\n        address payable _creator\n    ) external payable returns (uint256 tokenId);\n\n    /**\n     * @notice Create CTAG token from tag string.\n     *\n     * Reverts if tag exists or is invalid.\n     *\n     * Only ETS Relayer contracts may call this function.\n     *\n     * @param _tag Tag string.\n     * @param _creator Address credited with creating CTAG.\n     * @return tokenId Id of CTAG token.\n     */\n    function createTag(string calldata _tag, address payable _creator) external payable returns (uint256 tokenId);\n\n    /**\n     * @notice Apply one or more tags to a targetURI using tagging record raw client input data.\n     *\n     * Like it's sister function applyTagsWithCompositeKey, records new ETS Tagging Record or appends tags to an\n     * existing record if found to already exist. This function differs in that it creates new ETS target records\n     * and CTAG tokens for novel targetURIs and hastag strings respectively. This function can only be called by\n     * Relayer contracts.\n     *\n     * @param _rawInput Raw client input data formed as TaggingRecordRawInput struct.\n     * @param _tagger Address that calls Relayer to tag a targetURI.\n     */\n    function applyTagsWithRawInput(TaggingRecordRawInput calldata _rawInput, address payable _tagger) external payable;\n\n    /**\n     * @notice Apply one or more tags to a targetId using using tagging record composite key.\n     *\n     * Records new ETS Tagging Record to the blockchain or appends tags if Tagging Record already exists. CTAGs and\n     * targetId are created if they don't exist. Caller must be Relayer contract.\n     *\n     * @param _tagIds Array of CTAG token Ids.\n     * @param _targetId targetId of the URI being tagged. See ETSTarget.sol\n     * @param _recordType Arbitrary identifier for type of tagging record.\n     * @param _tagger Address of that calls Relayer to create tagging record.\n     */\n    function applyTagsWithCompositeKey(\n        uint256[] calldata _tagIds,\n        uint256 _targetId,\n        string memory _recordType,\n        address payable _tagger\n    ) external payable;\n\n    /**\n     * @notice Replace entire tag set in tagging record using raw data for record lookup.\n     *\n     * If supplied tag strings don't have CTAGs, new ones are minted.\n     *\n     * @param _rawInput Raw client input data formed as TaggingRecordRawInput struct.\n     * @param _tagger Address that calls Relayer to tag a targetURI.\n     */\n    function replaceTagsWithRawInput(\n        TaggingRecordRawInput calldata _rawInput,\n        address payable _tagger\n    ) external payable;\n\n    /**\n     * @notice Replace entire tag set in tagging record using composite key for record lookup.\n     *\n     * This function overwrites the tags in a tagging record with the supplied tags, only\n     * charging for the new tags in the replacement set.\n     *\n     * @param _tagIds Array of CTAG token Ids.\n     * @param _targetId targetId of the URI being tagged. See ETSTarget.sol\n     * @param _recordType Arbitrary identifier for type of tagging record.\n     * @param _tagger Address of that calls Relayer to create tagging record.\n     */\n    function replaceTagsWithCompositeKey(\n        uint256[] calldata _tagIds,\n        uint256 _targetId,\n        string memory _recordType,\n        address payable _tagger\n    ) external payable;\n\n    /**\n     * @notice Remove one or more tags from a tagging record using raw data for record lookup.\n     *\n     * @param _rawInput Raw client input data formed as TaggingRecordRawInput struct.\n     * @param _tagger Address that calls Relayer to tag a targetURI.\n     */\n    function removeTagsWithRawInput(TaggingRecordRawInput calldata _rawInput, address _tagger) external;\n\n    /**\n     * @notice Remove one or more tags from a tagging record using composite key for record lookup.\n     *\n     * @param _tagIds Array of CTAG token Ids.\n     * @param _targetId targetId of the URI being tagged. See ETSTarget.sol\n     * @param _recordType Arbitrary identifier for type of tagging record.\n     * @param _tagger Address of that calls Relayer to create tagging record.\n     */\n    function removeTagsWithCompositeKey(\n        uint256[] calldata _tagIds,\n        uint256 _targetId,\n        string memory _recordType,\n        address payable _tagger\n    ) external;\n\n    /**\n     * @notice Append one or more tags to a tagging record.\n     *\n     * @param _taggingRecordId tagging record being updated.\n     * @param _tagIds Array of CTAG token Ids.\n     */\n    function appendTags(uint256 _taggingRecordId, uint256[] calldata _tagIds) external payable;\n\n    /**\n     * @notice Replaces tags in tagging record.\n     *\n     * This function overwrites the tags in a tagging record with the supplied tags, only\n     * charging for the new tags in the replacement set.\n     *\n     * @param _taggingRecordId tagging record being updated.\n     * @param _tagIds Array of CTAG token Ids.\n     */\n    function replaceTags(uint256 _taggingRecordId, uint256[] calldata _tagIds) external payable;\n\n    /**\n     * @notice Remove one or more tags from a tagging record.\n     *\n     * @param _taggingRecordId tagging record being updated.\n     * @param _tagIds Array of CTAG token Ids.\n     */\n    function removeTags(uint256 _taggingRecordId, uint256[] calldata _tagIds) external;\n\n    /**\n     * @notice Function for withdrawing funds from an accrual account. Can be called by the account owner\n     * or on behalf of the account. Does nothing when there is nothing due to the account.\n     *\n     * @param _account Address of account being drawn down and which will receive the funds.\n     */\n    function drawDown(address payable _account) external;\n\n    // ============ PUBLIC VIEW FUNCTIONS ============\n\n    /**\n     * @notice Compute a taggingRecordId from raw input.\n     *\n     * @param _rawInput Raw client input data formed as TaggingRecordRawInput struct.\n     * @param _relayer Address of tagging record Relayer contract.\n     * @param _tagger Address interacting with Relayer to tag content (\"Tagger\").\n     *\n     * @return taggingRecordId Unique identifier for a tagging record.\n     */\n    function computeTaggingRecordIdFromRawInput(\n        TaggingRecordRawInput calldata _rawInput,\n        address _relayer,\n        address _tagger\n    ) external view returns (uint256 taggingRecordId);\n\n    /**\n     * @notice Compute & return a taggingRecordId.\n     *\n     * Every TaggingRecord in ETS is mapped to by it's taggingRecordId. This Id is a composite key\n     * composed of targetId, recordType, relayer contract address and tagger address hashed and cast as a uint256.\n     *\n     * @param _targetId Id of target being tagged (see ETSTarget.sol).\n     * @param _recordType Arbitrary identifier for type of tagging record.\n     * @param _relayer Address of tagging record Relayer contract.\n     * @param _tagger Address interacting with Relayer to tag content (\"Tagger\").\n     *\n     * @return taggingRecordId Unique identifier for a tagging record.\n     */\n    function computeTaggingRecordIdFromCompositeKey(\n        uint256 _targetId,\n        string memory _recordType,\n        address _relayer,\n        address _tagger\n    ) external pure returns (uint256 taggingRecordId);\n\n    /**\n     * @notice Compute tagging fee for raw input and desired action.\n     *\n     * @param _rawInput Raw client input data formed as TaggingRecordRawInput struct.\n     * @param _relayer Address of tagging record Relayer contract.\n     * @param _tagger Address interacting with Relayer to tag content (\"Tagger\").\n     * @param _action Integer representing action to be performed according to enum TaggingAction.\n     *\n     * @return fee Calculated tagging fee in ETH/Matic\n     * @return tagCount Number of new tags being added to tagging record.\n     */\n    function computeTaggingFeeFromRawInput(\n        TaggingRecordRawInput memory _rawInput,\n        address _relayer,\n        address _tagger,\n        TaggingAction _action\n    ) external view returns (uint256 fee, uint256 tagCount);\n\n    /**\n     * @notice Compute tagging fee for CTAGs, tagging record composite key and desired action.\n     *\n     * @param _tagIds Array of CTAG token Ids.\n     * @param _relayer Address of tagging record Relayer contract.\n     * @param _tagger Address interacting with Relayer to tag content (\"Tagger\").\n     * @param _action Integer representing action to be performed according to enum TaggingAction.\n     *\n     * @return fee Calculated tagging fee in ETH/Matic\n     * @return tagCount Number of new tags being added to tagging record.\n     */\n    function computeTaggingFeeFromCompositeKey(\n        uint256[] memory _tagIds,\n        uint256 _targetId,\n        string calldata _recordType,\n        address _relayer,\n        address _tagger,\n        TaggingAction _action\n    ) external view returns (uint256 fee, uint256 tagCount);\n\n    /**\n     * @notice Compute tagging fee for CTAGs, tagging record id and desired action.\n     *\n     * If the global, service wide tagging fee is set (see ETS.taggingFee() & ETS.setTaggingFee()) ETS charges a per tag for all\n     * new tags applied to a tagging record. This applies to both new tagging records and modified tagging records.\n     *\n     * Computing the tagging fee involves checking to see if a tagging record exists and if so, given the desired action\n     * (append or replace) determining the number of new tags being added and multiplying by the ETS per tag fee.\n     *\n     * @param _taggingRecordId Id of tagging record.\n     * @param _tagIds Array of CTAG token Ids.\n     * @param _action Integer representing action to be performed according to enum TaggingAction.\n     *\n     * @return fee Calculated tagging fee in ETH/Matic\n     * @return tagCount Number of new tags being added to tagging record.\n     */\n    function computeTaggingFee(\n        uint256 _taggingRecordId,\n        uint256[] memory _tagIds,\n        TaggingAction _action\n    ) external view returns (uint256 fee, uint256 tagCount);\n\n    /**\n     * @notice Retrieve a tagging record from it's raw input.\n     *\n     * @param _rawInput Raw client input data formed as TaggingRecordRawInput struct.\n     * @param _relayer Address of tagging record Relayer contract.\n     * @param _tagger Address interacting with Relayer to tag content (\"Tagger\").\n     *\n     * @return tagIds CTAG token ids.\n     * @return targetId TargetId that was tagged.\n     * @return recordType Type of tagging record.\n     * @return relayer Address of tagging record Relayer contract.\n     * @return tagger Address interacting with Relayer to tag content (\"Tagger\").\n     */\n    function getTaggingRecordFromRawInput(\n        TaggingRecordRawInput memory _rawInput,\n        address _relayer,\n        address _tagger\n    )\n        external\n        view\n        returns (uint256[] memory tagIds, uint256 targetId, string memory recordType, address relayer, address tagger);\n\n    /**\n     * @notice Retrieve a tagging record from composite key parts.\n     *\n     * @param _targetId Id of target being tagged.\n     * @param _recordType Arbitrary identifier for type of tagging record.\n     * @param _relayer Address of Relayer contract that wrote tagging record.\n     * @param _tagger Address of wallet that initiated tagging record via relayer.\n     *\n     * @return tagIds CTAG token ids.\n     * @return targetId TargetId that was tagged.\n     * @return recordType Type of tagging record.\n     * @return relayer Address of tagging record Relayer contract.\n     * @return tagger Address interacting with Relayer to tag content (\"Tagger\").\n     */\n    function getTaggingRecordFromCompositeKey(\n        uint256 _targetId,\n        string memory _recordType,\n        address _relayer,\n        address _tagger\n    )\n        external\n        view\n        returns (uint256[] memory tagIds, uint256 targetId, string memory recordType, address relayer, address tagger);\n\n    /**\n     * @notice Retrieve a tagging record from Id.\n     *\n     * @param _id taggingRecordId.\n     *\n     * @return tagIds CTAG token ids.\n     * @return targetId TargetId that was tagged.\n     * @return recordType Type of tagging record.\n     * @return relayer Address of tagging record Relayer contract.\n     * @return tagger Address interacting with Relayer to tag content (\"Tagger\").\n     */\n    function getTaggingRecordFromId(\n        uint256 _id\n    )\n        external\n        view\n        returns (uint256[] memory tagIds, uint256 targetId, string memory recordType, address relayer, address tagger);\n\n    /**\n     * @notice Check that a tagging record exists for given raw input.\n     *\n     * @param _rawInput Raw client input data formed as TaggingRecordRawInput struct.\n     * @param _relayer Address of tagging record Relayer contract.\n     * @param _tagger Address interacting with Relayer to tag content (\"Tagger\").\n     *\n     * @return boolean; true for exists, false for not.\n     */\n    function taggingRecordExistsByRawInput(\n        TaggingRecordRawInput memory _rawInput,\n        address _relayer,\n        address _tagger\n    ) external view returns (bool);\n\n    /**\n     * @notice Check that a tagging record exists by it's componsite key parts.\n     *\n     * @param _targetId Id of target being tagged.\n     * @param _recordType Arbitrary identifier for type of tagging record.\n     * @param _relayer Address of Relayer contract that wrote tagging record.\n     * @param _tagger Address of wallet that initiated tagging record via relayer.\n     *\n     * @return boolean; true for exists, false for not.\n     */\n    function taggingRecordExistsByCompositeKey(\n        uint256 _targetId,\n        string memory _recordType,\n        address _relayer,\n        address _tagger\n    ) external view returns (bool);\n\n    /**\n     * @notice Check that a tagging record exsits by it's Id.\n     *\n     * @param _taggingRecordId taggingRecordId.\n     *\n     * @return boolean; true for exists, false for not.\n     */\n    function taggingRecordExists(uint256 _taggingRecordId) external view returns (bool);\n\n    /**\n     * @notice Function to check how much MATIC has been accrued by an address factoring in amount paid out.\n     *\n     * @param _account Address of the account being queried.\n     * @return _due Amount of WEI in MATIC due to account.\n     */\n    function totalDue(address _account) external view returns (uint256 _due);\n\n    /**\n     * @notice Function to retrieve the ETS platform tagging fee.\n     *\n     * @return tagging fee.\n     */\n    function taggingFee() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IETSAccessControls.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title IETSAccessControls\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  ███████╗████████╗███████╗\n *  ██╔════╝╚══██╔══╝██╔════╝\n *  █████╗     ██║   ███████╗\n *  ██╔══╝     ██║   ╚════██║\n *  ███████╗   ██║   ███████║`\n *  ╚══════╝   ╚═╝   ╚══════╝\n *\n * @notice This is the interface for the ETSAccessControls contract which allows ETS Core Dev\n * Team to administer roles and control access to various parts of the ETS Platform.\n * ETSAccessControls contract contains a mix of public and administrator only functions.\n */\n\npragma solidity ^0.8.10;\n\nimport { IAccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\";\n\ninterface IETSAccessControls is IAccessControlUpgradeable {\n    /**\n     * @dev emitted when the ETS Platform address is set.\n     *\n     * @param newAddress wallet address platform is being set to.\n     * @param prevAddress previous platform address.\n     */\n    event PlatformSet(address newAddress, address prevAddress);\n\n    /**\n     * @dev emitted when a Relayer contract is added & enabled in ETS.\n     *\n     * Relayer contracts are not required implement all ETS Core API functions. Therefore, to ease\n     * testing of ETS Core API fuinctions, ETS permits addition of ETS owned wallet addresses as Relayers.\n     *\n     * @param relayer Relayer contract address.\n     */\n    event RelayerAdded(address relayer);\n\n    /**\n     * @dev emitted when a Relayer contract is paused or unpaused.\n     *\n     * @param relayer Address that had pause toggled.\n     */\n    event RelayerLockToggled(address relayer);\n\n    /**\n     * @notice Sets the Platform wallet address. Can only be called by address with DEFAULT_ADMIN_ROLE.\n     *\n     * @param _platform The new Platform address to set.\n     */\n    function setPlatform(address payable _platform) external;\n\n    /**\n     * @notice Adds a Relayer contract to ETS. Can only be called by address\n     * with DEFAULT_ADMIN_ROLE.\n     *\n     * @param _relayer Address of the Relayer contract. Must conform to IETSRelayer.\n     * @param _name Human readable name of the Relayer.\n     * @param _owner Address of relayer owner.\n     */\n    function registerRelayer(address _relayer, string calldata _name, address _owner) external;\n\n    /**\n     * @notice Pause relayer given the relayer owner address. Callable by Platform only.\n     *\n     * @param _relayerOwner Address of the Relayer owner.\n     */\n    function pauseRelayerByOwnerAddress(address _relayerOwner) external;\n\n    /**\n     * @notice Change the relayer owner as stored in ETSAccessControls. Callable from Relayer only.\n     * Called via changeOwner() on a relayer.\n     *\n     * @param _currentOwner Address of the current relayer owner.\n     * @param _newOwner Address of the new relayer owner.\n     */\n    function changeRelayerOwner(address _currentOwner, address _newOwner) external;\n\n    /**\n     * @notice Pauses/Unpauses a Relayer contract. Can only be called by address\n     * with DEFAULT_ADMIN_ROLE.\n     *\n     * @param _relayer Address of the Relayer contract.\n     */\n    function toggleRelayerLock(address _relayer) external;\n\n    /**\n     * @notice Sets the role admin for a given role. An address with role admin can grant or\n     * revoke that role for other addresses. Can only be called by address with DEFAULT_ADMIN_ROLE.\n     *\n     * @param _role bytes32 representation of role being administered.\n     * @param _adminRole bytes32 representation of administering role.\n     */\n    function setRoleAdmin(bytes32 _role, bytes32 _adminRole) external;\n\n    /**\n     * @notice Checks whether given address has SMART_CONTRACT role.\n     *\n     * @param _addr Address being checked.\n     * @return boolean True if address has SMART_CONTRACT role.\n     */\n    function isSmartContract(address _addr) external view returns (bool);\n\n    /**\n     * @notice Checks whether given address has DEFAULT_ADMIN_ROLE role.\n     *\n     * @param _addr Address being checked.\n     * @return boolean True if address has DEFAULT_ADMIN_ROLE role.\n     */\n    function isAdmin(address _addr) external view returns (bool);\n\n    /**\n     * @notice Checks whether given address has AUCTION_ORACLE_ROLE role.\n     *\n     * @param _addr Address being checked.\n     * @return boolean True if address has AUCTION_ORACLE_ROLE role.\n     */\n    function isAuctionOracle(address _addr) external view returns (bool);\n\n    /**\n     * @notice Checks whether given address can act as relayer factory.\n     *\n     * @param _addr Address being checked.\n     * @return boolean True if address can act as relayer factory.\n     */\n    function isRelayerFactory(address _addr) external view returns (bool);\n\n    /**\n     * @notice Checks whether given address is a relayer.\n     *\n     * @param _addr Address being checked.\n     * @return boolean True if address can be a relayer.\n     */\n    function isRelayer(address _addr) external view returns (bool);\n\n    /**\n     * @notice Checks whether given address is a registered Relayer and not paused.\n     *\n     * @param _addr Address being checked.\n     * @return boolean True if address is a Relayer and not paused.\n     */\n    function isRelayerAndNotPaused(address _addr) external view returns (bool);\n\n    /**\n     * @notice Checks relayer is paused by ETS Platform.\n     *\n     * @param _addr Address being checked.\n     * @return boolean True if relayer address is paused by platform.\n     */\n    function isRelayerLocked(address _addr) external view returns (bool);\n\n    /**\n     * @notice Checks whether given address owns a relayer.\n     *\n     * @param _addr Address being checked.\n     * @return boolean True if address owns a relayer.\n     */\n    function isRelayerByOwner(address _addr) external view returns (bool);\n\n    /**\n     * @notice Checks whether given address has RELAYER_ADMIN role.\n     *\n     * @param _addr Address being checked.\n     * @return boolean True if address has RELAYER_ADMIN role.\n     */\n    function isRelayerAdmin(address _addr) external view returns (bool);\n\n    /**\n     * @notice Checks whether given Relayer Name is a registered Relayer.\n     *\n     * @param _name Name being checked.\n     * @return boolean True if _name is a Relayer.\n     */\n    function isRelayerByName(string calldata _name) external view returns (bool);\n\n    /**\n     * @notice Checks whether given address is a registered Relayer.\n     *\n     * @param _addr Address being checked.\n     * @return boolean True if address is a registered Relayer.\n     */\n    function isRelayerByAddress(address _addr) external view returns (bool);\n\n    /**\n     * @notice Get relayer address from it's name.\n     *\n     * @param _name Name of relayer.\n     * @return Address of relayer.\n     */\n    function getRelayerAddressFromName(string calldata _name) external view returns (address);\n\n    /**\n     * @notice Get relayer name from it's address.\n     *\n     * @param _address Adsdress of relayer.\n     * @return Name of relayer.\n     */\n    function getRelayerNameFromAddress(address _address) external view returns (string calldata);\n\n    /**\n     * @notice Get relayer address from its owner address.\n     *\n     * @param _address address of relayer owner.\n     * @return Address of relayer.\n     */\n    function getRelayerAddressFromOwner(address _address) external view returns (address);\n\n    /**\n     * @notice Returns wallet address for ETS Platform.\n     *\n     * @return ETS Platform address.\n     */\n    function getPlatformAddress() external view returns (address payable);\n}\n"
    },
    "contracts/interfaces/IETSAuctionHouse.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/**\n * @title IETSAuctionHouse\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  ███████╗████████╗███████╗\n *  ██╔════╝╚══██╔══╝██╔════╝\n *  █████╗     ██║   ███████╗\n *  ██╔══╝     ██║   ╚════██║\n *  ███████╗   ██║   ███████║`\n *  ╚══════╝   ╚═╝   ╚══════╝\n *\n * @notice This is the standard interface for the ETSAuctionHouse.sol contract.\n * Includes both public and administration functions.\n */\n\npragma solidity ^0.8.6;\n\ninterface IETSAuctionHouse {\n    struct Auction {\n        // Incremented auction number\n        uint256 auctionId;\n        // Id of token being auctioned.\n        uint256 tokenId;\n        // The current highest bid amount\n        uint256 amount;\n        // The time that the auction started\n        uint256 startTime;\n        // The time that the auction is scheduled to end\n        uint256 endTime;\n        // The minimum price of the first bid\n        uint256 reservePrice;\n        // The address of the current highest bid\n        address payable bidder;\n        // Address of the auctioneer. Defaults to ETS.\n        address payable auctioneer;\n        // Whether or not the auction has been settled\n        bool settled;\n    }\n\n    event RequestCreateAuction();\n\n    event AuctionBid(uint256 indexed auctionId, address sender, uint256 value, bool extended);\n\n    event AuctionCreated(uint256 indexed auctionId, uint256 indexed tokenId, uint256 tokenAuctionNumber);\n\n    event AuctionExtended(uint256 indexed auctionId, uint256 endTime);\n\n    event AuctionSettled(uint256 indexed auctionId);\n\n    event AuctionsMaxSet(uint256 maxAuctions);\n\n    event AuctionDurationSet(uint256 duration);\n\n    event AuctionMinBidIncrementPercentageSet(uint8 minBidIncrementPercentagePrice);\n\n    event AuctionReservePriceSet(uint256 reservePrice);\n\n    event AuctionTimeBufferSet(uint256 timeBuffer);\n\n    event AuctionProceedPercentagesSet(\n        uint256 platformPercentage,\n        uint256 relayerPercentage,\n        uint256 creatorPercentage\n    );\n\n    event AuctionProceedsWithdrawn(address indexed who, uint256 amount);\n\n    function pause() external;\n\n    function unpause() external;\n\n    function setReservePrice(uint256 _reservePrice) external;\n\n    function setTimeBuffer(uint256 timeBuffer) external;\n\n    function setProceedPercentages(uint256 _platformPercentage, uint256 _relayerPercentage) external;\n\n    function createBid(uint256 auctionId) external payable;\n\n    function settleCurrentAndCreateNewAuction(uint256 _tokenId) external;\n\n    function settleAuction(uint256 _tokenId) external;\n\n    function createNextAuction() external;\n\n    function fulfillRequestCreateAuction(uint256 _tokenId) external;\n\n    function auctionExists(uint256 _tokenId) external returns (bool);\n\n    function auctionEnded(uint256 _tokenId) external returns (bool);\n\n    function auctionSettled(uint256 _tokenId) external returns (bool);\n\n    function getActiveCount() external returns (uint256);\n\n    function getTotalCount() external returns (uint256);\n\n    function getAuction(uint256 _tokenId) external returns (Auction memory auction);\n\n    function getBalance() external returns (uint);\n\n    function totalDue(address _account) external returns (uint256 _due);\n\n    function drawDown(address payable _account) external;\n}\n"
    },
    "contracts/interfaces/IETSEnrichTarget.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title IETSEnrichTarget\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  ███████╗████████╗███████╗\n *  ██╔════╝╚══██╔══╝██╔════╝\n *  █████╗     ██║   ███████╗\n *  ██╔══╝     ██║   ╚════██║\n *  ███████╗   ██║   ███████║`\n *  ╚══════╝   ╚═╝   ╚══════╝\n *\n * @notice This is the interface for the ETSEnrichTarget.sol contract that handles the enrichment of\n * Target metadata using off-chain APIs.\n *\n * In order to keep the on-chain recording of new Target records lightweight and inexpensive,\n * the createTarget() function (ETSTarget.sol) requires only a URI string (targetURI). To augment this,\n * we are developing a hybrid onchain/off-chain Enrich Target flow for the purpose of collecting\n * additional metadata about a Target and saving it back on-chain.\n *\n * The flow begins with the requestEnrichTarget() function (see below) which takes a targetId as an\n * argument. If the Target exists, the function emits the targetId via the RequestEnrichTarget event.\n *\n * An OpenZeppelin Defender Sentinel is listening for this event, and when detected, passes the\n * targetId to an ETS off-chain service we call the Enrich Target API, which extracts the Target URI,\n * collects metadata about the URI and saves it in json format to IPFS. The IPFS entpoint is posted\n * back on-chain via fulfillEnrichTarget() thus updating the Target data struct.\n *\n * Future implementation should utilize ChainLink in place of OpenZeppelin for better decentralization.\n */\n\npragma solidity ^0.8.10;\n\ninterface IETSEnrichTarget {\n    /**\n     * @dev emitted when Target enrichment is requested via requestEnrichTarget().\n     *\n     * @param targetId Target record to enrich.\n     */\n    event RequestEnrichTarget(uint256 targetId);\n\n    /**\n     * @notice Request enrichment for a Target using the hybrid ETS Enrich Target API.\n     *\n     * @param _targetId Id of Target being enriched.\n     */\n    function requestEnrichTarget(uint256 _targetId) external;\n\n    /**\n     * @notice Updates Target record with additional metadata stored behind IPFS hash.\n     *\n     * @param _targetId Id of Target being enriched & updated.\n     * @param _ipfsHash IPFS hash with metadata related to the Target.\n     * @param _httpStatus HTTP response code from off-chain ETS Enrich Target API.\n     */\n    function fulfillEnrichTarget(uint256 _targetId, string calldata _ipfsHash, uint256 _httpStatus) external;\n}\n"
    },
    "contracts/interfaces/IETSTarget.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title IETSTarget\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  ███████╗████████╗███████╗\n *  ██╔════╝╚══██╔══╝██╔════╝\n *  █████╗     ██║   ███████╗\n *  ██╔══╝     ██║   ╚════██║\n *  ███████╗   ██║   ███████║`\n *  ╚══════╝   ╚═╝   ╚══════╝\n *\n * @notice This is the standard interface for the core ETSTarget.sol contract. It includes both public\n * and administration functions.\n *\n * In ETS, a \"Target\" is our data structure, stored onchain, that references/points to a URI. Target records\n * are identified in ETS by their Id (targetId) which is a unsigned integer computed from the URI string.\n * Target Ids are combined with CTAG Ids by ETS core (ETS.sol) to form \"Tagging Records\".\n *\n * For context, from Wikipedia, URI is short for Uniform Resource Identifier and is a unique sequence of\n * characters that identifies a logical or physical resource used by web technologies. URIs may be used to\n * identify anything, including real-world objects, such as people and places, concepts, or information\n * resources such as web pages and books.\n *\n * For our purposes, as much as possible, we are restricting our interpretation of URIs to the more technical\n * parameters defined by the IETF in [RFC3986](https://www.rfc-editor.org/rfc/rfc3986). For newer protocols, such\n * as blockchains, For newer protocols, such as blockchains we will lean on newer emerging URI standards such\n * as the [Blink](https://w3c-ccg.github.io/blockchain-links) and [BIP-122](https://github.com/bitcoin/bips/blob/master/bip-0122.mediawiki)\n *\n * One the thing to keep in mind with URIs & ETS Targets is that differently shaped URIs can sometimes point to the same\n * resource. The effect of that is that different Target IDs in ETS can similarly point to the same resource.\n */\n\npragma solidity ^0.8.10;\n\ninterface IETSTarget {\n    /**\n     * @notice Data structure for an ETS Target.\n     *\n     * @param targetURI Unique resource identifier Target points to\n     * @param createdBy Address of IETSTargetTagger implementation that created Target\n     * @param enriched block timestamp when Target was last enriched. Defaults to 0\n     * @param httpStatus https status of last response from ETSEnrichTarget API eg. \"404\", \"200\". defaults to 0\n     * @param ipfsHash ipfsHash of additional metadata for Target collected by ETSEnrichTarget API\n     */\n    struct Target {\n        string targetURI;\n        address createdBy;\n        uint256 enriched;\n        uint256 httpStatus;\n        string ipfsHash;\n    }\n\n    /**\n     * @dev emitted when the ETSAccessControls is set.\n     *\n     * @param etsAccessControls contract address ETSAccessControls is set to.\n     */\n    event AccessControlsSet(address etsAccessControls);\n\n    /**\n     * @dev emitted when the ETSEnrichTarget API address is set.\n     *\n     * @param etsEnrichTarget contract address ETSEnrichTarget is set to.\n     */\n    event EnrichTargetSet(address etsEnrichTarget);\n\n    /**\n     * @dev emitted when a new Target is created.\n     *\n     * @param targetId Unique Id of new Target.\n     */\n    event TargetCreated(uint256 targetId);\n\n    /**\n     * @dev emitted when an existing Target is updated.\n     *\n     * @param targetId Id of Target being updated.\n     */\n    event TargetUpdated(uint256 targetId);\n\n    /**\n     * @notice Sets ETSEnrichTarget contract address so that Target metadata enrichment\n     * functions can be called from ETSTarget.\n     *\n     * @param _etsEnrichTarget Address of ETSEnrichTarget contract.\n     */\n    function setEnrichTarget(address _etsEnrichTarget) external;\n\n    /**\n     * @notice Get ETS targetId from URI.\n     *\n     * Combo function that given a URI string will return it's ETS targetId if it exists,\n     * or create a new Target record and return corresponding targetId.\n     *\n     * @param _targetURI URI passed in as string\n     * @return Id of ETS Target record\n     */\n    function getOrCreateTargetId(string memory _targetURI) external returns (uint256);\n\n    /**\n     * @notice Create a Target record and return it's targetId.\n     *\n     * @param _targetURI URI passed in as string\n     * @return targetId Id of ETS Target record\n     */\n    function createTarget(string memory _targetURI) external returns (uint256 targetId);\n\n    /**\n     * @notice Update a Target record.\n     *\n     * @param _targetId Id of Target being updated.\n     * @param _targetURI Unique resource identifier Target points to.\n     * @param _enriched block timestamp when Target was last enriched\n     * @param _httpStatus https status of last response from ETSEnrichTarget API eg. \"404\", \"200\". defaults to 0\n     * @param _ipfsHash ipfsHash of additional metadata for Target collected by ETSEnrichTarget API\n\n     * @return success true when Target is successfully updated.\n     */\n    function updateTarget(\n        uint256 _targetId,\n        string calldata _targetURI,\n        uint256 _enriched,\n        uint256 _httpStatus,\n        string calldata _ipfsHash\n    ) external returns (bool success);\n\n    /**\n     * @notice Function to deterministically compute & return a targetId.\n     *\n     * Every Target in ETS is mapped to by it's targetId. This Id is computed from\n     * the target URI sting hashed and cast as a uint256.\n     *\n     * Note: Function does not verify if Target record exists.\n     *\n     * @param _targetURI Unique resource identifier Target record points to.\n     * @return targetId Id of the potential Target record.\n     */\n    function computeTargetId(string memory _targetURI) external view returns (uint256 targetId);\n\n    /**\n     * @notice Check that a Target record exists for a given URI string.\n     *\n     * @param _targetURI Unique resource identifier Target record points to.\n     * @return true if Target record exists; false if not.\n     */\n    function targetExistsByURI(string memory _targetURI) external view returns (bool);\n\n    /**\n     * @notice Check that a Target record exists for a given computed targetId.\n     *\n     * @param _targetId targetId uint computed from URI via computeTargetId().\n     * @return true if Target record exists; false if not.\n     */\n    function targetExistsById(uint256 _targetId) external view returns (bool);\n\n    /**\n     * @notice Retrieve a Target record for a given URI string.\n     *\n     * Note: returns a struct with empty members when no Target exists.\n     *\n     * @param _targetURI Unique resource identifier Target record points to.\n     * @return Target record.\n     */\n    function getTargetByURI(string memory _targetURI) external view returns (Target memory);\n\n    /**\n     * @notice Retrieve a Target record for a computed targetId.\n     *\n     * Note: returns a struct with empty members when no Target exists.\n     *\n     * @param _targetId targetId uint computed from URI via computeTargetId().\n     * @return Target record.\n     */\n    function getTargetById(uint256 _targetId) external view returns (Target memory);\n}\n"
    },
    "contracts/interfaces/IETSToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title IETSToken\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  ███████╗████████╗███████╗\n *  ██╔════╝╚══██╔══╝██╔════╝\n *  █████╗     ██║   ███████╗\n *  ██╔══╝     ██║   ╚════██║\n *  ███████╗   ██║   ███████║`\n *  ╚══════╝   ╚═╝   ╚══════╝\n *\n * @notice This is the interface for the ETSToken.sol core contract that governs the creation & management\n * of Ethereum Tag Service composable tags (CTAGs).\n *\n * CTAGs are ERC-721 non-fungible tokens that store a single tag string and origin attribution data including\n * a \"Relayer\" address and a \"Creator\" address. The tag string must conform to a few simple validation rules.\n *\n * CTAGs are identified in ETS by their Id (tagId) which is an unsigned integer computed from the lowercased\n * tag \"display\" string. Given this, only one CTAG exists for a tag string regardless of its case. For\n * example, #Punks, #punks and #PUNKS all resolve to the same CTAG.\n *\n * CTAG Ids are combined with Target Ids (see ETSTarget.sol) by ETS core (ETS.sol) to form \"Tagging Records\".\n *\n * CTAGs may only be generated by Relayer contracts (see examples/ETSRelayer.sol) via ETS core (ETS.sol)\n */\n\npragma solidity ^0.8.10;\n\nimport { IERC721Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\n\ninterface IETSToken is IERC721Upgradeable {\n    /**\n     * @notice Data structure for CTAG Token.\n     *\n     * Only premium and reserved flags are editable.\n     *\n     * @param relayer Address of IETSTargetTagger implementation that created CTAG.\n     * @param creator Address interacting with relayer to initiate CTAG creation.\n     * @param display Display version of CTAG string.\n     * @param premium ETS governed boolean flag to identify a CTAG as premium/higher value.\n     * @param reserved ETS governed boolean flag to restrict a CTAG from release to auction.\n     */\n    struct Tag {\n        address relayer;\n        address creator;\n        string display;\n        bool premium;\n        bool reserved;\n    }\n\n    // Events\n\n    /**\n     * @dev emitted when the maximum character length of CTAG display string is set.\n     *\n     * @param maxStringLength maximum character length of string.\n     */\n    event TagMaxStringLengthSet(uint256 maxStringLength);\n\n    /**\n     * @dev emitted when the minimum character length of CTAG display string is set.\n     *\n     * @param minStringLength minimum character length of string.\n     */\n    event TagMinStringLengthSet(uint256 minStringLength);\n\n    /**\n     * @dev emitted when the ownership term length of a CTAG is set.\n     *\n     * @param termLength Ownership term length in days.\n     */\n    event OwnershipTermLengthSet(uint256 termLength);\n\n    /**\n     * @dev emitted when the ETS core contract is set.\n     *\n     * @param ets ets core contract address.\n     */\n    event ETSCoreSet(address ets);\n\n    /**\n     * @dev emitted when the ETS Access Controls is set.\n     *\n     * @param etsAccessControls contract address access controls is set to.\n     */\n    event AccessControlsSet(address etsAccessControls);\n\n    /**\n     * @dev emitted when a tag string is flagged/unflagged as premium prior to minting.\n     *\n     * @param tag tag string being flagged.\n     * @param isPremium boolean true for premium/false not premium.\n     */\n    event PremiumTagPreSet(string tag, bool isPremium);\n\n    /**\n     * @dev emitted when a CTAG is flagged/unflagged as premium subsequent to minting.\n     *\n     * @param tagId Id of CTAG token.\n     * @param isPremium boolean true for premium/false not premium.\n     */\n    event PremiumFlagSet(uint256 tagId, bool isPremium);\n\n    /**\n     * @dev emitted when a CTAG is flagged/unflagged as reserved subsequent to minting.\n     *\n     * @param tagId Id of CTAG token.\n     * @param isReserved boolean true for reserved/false for not reserved.\n     */\n    event ReservedFlagSet(uint256 tagId, bool isReserved);\n\n    /**\n     * @dev emitted when CTAG token is renewed.\n     *\n     * @param tokenId Id of CTAG token.\n     * @param caller address of renewer.\n     */\n    event TagRenewed(uint256 indexed tokenId, address indexed caller);\n\n    /**\n     * @dev emitted when CTAG token is recycled back to ETS.\n     *\n     * @param tokenId Id of CTAG token.\n     * @param caller address of recycler.\n     */\n    event TagRecycled(uint256 indexed tokenId, address indexed caller);\n\n    // ============ OWNER INTERFACE ============\n\n    /**\n     * @notice admin function to set maximum character length of CTAG display string.\n     *\n     * @param _tagMaxStringLength maximum character length of string.\n     */\n    function setTagMaxStringLength(uint256 _tagMaxStringLength) external;\n\n    /**\n     * @notice Admin function to set minimum  character length of CTAG display string.\n     *\n     * @param _tagMinStringLength minimum character length of string.\n     */\n    function setTagMinStringLength(uint256 _tagMinStringLength) external;\n\n    /**\n     * @notice Admin function to set the ownership term length of a CTAG is set.\n     *\n     * @param _ownershipTermLength Ownership term length in days.\n     */\n    function setOwnershipTermLength(uint256 _ownershipTermLength) external;\n\n    /**\n     * @notice Admin function to flag/unflag tag string(s) as premium prior to minting.\n     *\n     * @param _tags Array of tag strings.\n     * @param _isPremium Boolean true for premium, false for not premium.\n     */\n    function preSetPremiumTags(string[] calldata _tags, bool _isPremium) external;\n\n    /**\n     * @notice Admin function to flag/unflag CTAG(s) as premium.\n     *\n     * @param _tokenIds Array of CTAG Ids.\n     * @param _isPremium Boolean true for premium, false for not premium.\n     */\n    function setPremiumFlag(uint256[] calldata _tokenIds, bool _isPremium) external;\n\n    /**\n     * @notice Admin function to flag/unflag CTAG(s) as reserved.\n     *\n     * Tags flagged as reserved cannot be auctioned.\n     *\n     * @param _tokenIds Array of CTAG Ids.\n     * @param _reserved Boolean true for reserved, false for not reserved.\n     */\n    function setReservedFlag(uint256[] calldata _tokenIds, bool _reserved) external;\n\n    // ============ PUBLIC INTERFACE ============\n\n    /**\n     * @notice Get CTAG token Id from tag string.\n     *\n     * Combo function that accepts a tag string and returns it's CTAG token Id if it exists,\n     * or creates a new CTAG and returns corresponding Id.\n     *\n     * Only ETS Core can call this function.\n     *\n     * @param _tag Tag string.\n     * @param _relayer Address of Relayer contract calling ETS Core.\n     * @param _creator Address credited with creating CTAG.\n     * @return tokenId Id of CTAG token.\n     */\n    function getOrCreateTagId(\n        string calldata _tag,\n        address payable _relayer,\n        address payable _creator\n    ) external payable returns (uint256 tokenId);\n\n    /**\n     * @notice Create CTAG token from tag string.\n     *\n     * Reverts if tag exists or is invalid.\n     *\n     * Only ETS Core can call this function.\n     *\n     * @param _tag Tag string.\n     * @param _creator Address credited with creating CTAG.\n     * @return tokenId Id of CTAG token.\n     */\n    function createTag(\n        string calldata _tag,\n        address payable _relayer,\n        address payable _creator\n    ) external payable returns (uint256 tokenId);\n\n    /**\n     * @notice Renews ownership term of a CTAG.\n     *\n     * A \"CTAG ownership term\" is utilized to prevent CTAGs from being abandoned or inaccessable\n     * due to lost private keys.\n     *\n     * Any wallet address may renew the term of a CTAG for an owner. When renewed, the term\n     * is extended from the current block timestamp plus the ownershipTermLength public variable.\n     *\n     * @param _tokenId Id of CTAG token.\n     */\n    function renewTag(uint256 _tokenId) external;\n\n    /**\n     * @notice Recycles a CTAG back to ETS.\n     *\n     * When ownership term of a CTAG has expired, any wallet or contract may call this function\n     * to recycle the tag back to ETS. Once recycled, a tag may be auctioned again.\n     *\n     * @param _tokenId Id of CTAG token.\n     */\n    function recycleTag(uint256 _tokenId) external;\n\n    // ============ PUBLIC VIEW FUNCTIONS ============\n\n    /**\n     * @notice Function to deterministically compute & return a CTAG token Id.\n     *\n     * Every CTAG token and it's associated data struct is mapped to by it's token Id. This Id is computed\n     * from the \"display\" tag string lowercased, hashed and cast as an unsigned integer.\n     *\n     * Note: Function does not verify if CTAG record exists.\n     *\n     * @param _tag Tag string.\n     * @return Id of potential CTAG token id.\n     */\n    function computeTagId(string memory _tag) external pure returns (uint256);\n\n    /**\n     * @notice Check that a CTAG token exists for a given tag string.\n     *\n     * @param _tag Tag string.\n     * @return true if CTAG token exists; false if not.\n     */\n    function tagExistsByString(string calldata _tag) external view returns (bool);\n\n    /**\n     * @notice Check that CTAG token exists for a given computed token Id.\n     *\n     * @param _tokenId Token Id uint computed from tag string via computeTargetId().\n     * @return true if CTAG token exists; false if not.\n     */\n    function tagExistsById(uint256 _tokenId) external view returns (bool);\n\n    /**\n     * @notice Check if CTAG token ownership term has expired.\n     *\n     * @param _tokenId Token Id uint computed from tag string via computeTargetId().\n     * @return true if CTAG ownership term has expired; false if not.\n     */\n    function tagOwnershipTermExpired(uint256 _tokenId) external view returns (bool);\n\n    /**\n     * @notice Retrieve a CTAG record for a given tag string.\n     *\n     * Note: returns a struct with empty members when no CTAG exists.\n     *\n     * @param _tag Tag string.\n     * @return CTAG record as Tag struct.\n     */\n    function getTagByString(string calldata _tag) external view returns (Tag memory);\n\n    /**\n     * @notice Retrieve a CTAG record for a given token Id.\n     *\n     * Note: returns a struct with empty members when no CTAG exists.\n     *\n     * @param _tokenId CTAG token Id.\n     * @return CTAG record as Tag struct.\n     */\n    function getTagById(uint256 _tokenId) external view returns (Tag memory);\n\n    /**\n     * @notice Retrieve wallet address for ETS Platform.\n     *\n     * @return wallet address for ETS Platform.\n     */\n    function getPlatformAddress() external view returns (address payable);\n\n    /**\n     * @notice Retrieve Creator address for a CTAG token.\n     *\n     * @param _tokenId CTAG token Id.\n     * @return _creator Creator address of the CTAG.\n     */\n    function getCreatorAddress(uint256 _tokenId) external view returns (address);\n\n    /**\n     * @notice Retrieve last renewal block timestamp for a CTAG.\n     *\n     * @param _tokenId CTAG token Id.\n     * @return Block timestamp.\n     */\n    function getLastRenewed(uint256 _tokenId) external view returns (uint256);\n\n    /**\n     * @notice Retrieve CTAG ownership term length global setting.\n     *\n     * @return Term length in days.\n     */\n    function getOwnershipTermLength() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IWMATIC.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\ninterface IWMATIC {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n\n    function transfer(address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/libraries/UintArrayUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n// Adapted from Cryptofin labs Array Utilities\n// https://github.com/cryptofinlabs/cryptofin-solidity/blob/master/contracts/array-utils/AddressArrayUtils.sol\n\nlibrary UintArrayUtils {\n    /**\n     * Finds the index of the first occurrence of the given element.\n     * @param A The input array to search\n     * @param a The value to find\n     * @return Returns (index and isIn) for the first occurrence starting from index 0\n     */\n    function indexOf(uint256[] memory A, uint256 a) internal pure returns (uint256, bool) {\n        uint256 length = A.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (A[i] == a) {\n                return (i, true);\n            }\n        }\n        return (0, false);\n    }\n\n    /**\n     * Returns true if the value is present in the list. Uses indexOf internally.\n     * @param A The input array to search\n     * @param a The value to find\n     * @return Returns isIn for the first occurrence starting from index 0\n     */\n    function contains(uint256[] memory A, uint256 a) internal pure returns (bool) {\n        (, bool isIn) = indexOf(A, a);\n        return isIn;\n    }\n\n    /**\n     * Computes the difference of two arrays. Assumes there are no duplicates.\n     * @param A The first array\n     * @param B The second array\n     * @return A - B; an array of values in A not found in B.\n     */\n    function difference(uint256[] memory A, uint256[] memory B) internal pure returns (uint256[] memory) {\n        uint256 length = A.length;\n        bool[] memory includeMap = new bool[](length);\n        uint256 count = 0;\n        // First count the new length because can't push for in-memory arrays\n        for (uint256 i = 0; i < length; i++) {\n            uint256 e = A[i];\n            if (!contains(B, e)) {\n                includeMap[i] = true;\n                count++;\n            }\n        }\n        uint256[] memory newItems = new uint256[](count);\n        uint256 j = 0;\n        for (uint256 i = 0; i < length; i++) {\n            if (includeMap[i]) {\n                newItems[j] = A[i];\n                j++;\n            }\n        }\n        return newItems;\n    }\n\n    /**\n     * Returns the intersection of two arrays. Arrays are treated as collections, so duplicates are kept.\n     * @param A The first array\n     * @param B The second array\n     * @return The intersection of the two arrays\n     */\n    function intersect(uint256[] memory A, uint256[] memory B) internal pure returns (uint256[] memory) {\n        uint256 length = A.length;\n        bool[] memory includeMap = new bool[](length);\n        uint256 newLength = 0;\n        for (uint256 i = 0; i < length; i++) {\n            if (contains(B, A[i])) {\n                includeMap[i] = true;\n                newLength++;\n            }\n        }\n        uint256[] memory newArray = new uint256[](newLength);\n        uint256 j = 0;\n        for (uint256 i = 0; i < length; i++) {\n            if (includeMap[i]) {\n                newArray[j] = A[i];\n                j++;\n            }\n        }\n        return newArray;\n    }\n\n    /**\n     * Returns the combination of two arrays\n     * @param A The first array\n     * @param B The second array\n     * @return Returns A extended by B\n     */\n    function extend(uint256[] memory A, uint256[] memory B) internal pure returns (uint256[] memory) {\n        uint256 aLength = A.length;\n        uint256 bLength = B.length;\n        uint256[] memory newArray = new uint256[](aLength + bLength);\n        for (uint256 i = 0; i < aLength; i++) {\n            newArray[i] = A[i];\n        }\n        for (uint256 i = 0; i < bLength; i++) {\n            newArray[aLength + i] = B[i];\n        }\n        return newArray;\n    }\n}\n"
    },
    "contracts/mocks/ERC721BurnableMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Hello\npragma solidity ^0.8.10;\n\nimport { ERC721Burnable, ERC721 } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\n\ncontract ERC721BurnableMock is ERC721Burnable {\n    // solhint-disable no-empty-blocks\n    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}\n\n    function exists(uint256 tokenId) public view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public {\n        _safeMint(to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId, bytes memory _data) public {\n        _safeMint(to, tokenId, _data);\n    }\n}\n"
    },
    "contracts/mocks/ERC721ReceiverMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport { IERC721Receiver } from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\ncontract ERC721ReceiverMock is IERC721Receiver {\n    enum Error {\n        None,\n        RevertWithMessage,\n        RevertWithoutMessage,\n        Panic\n    }\n\n    bytes4 private immutable _retval;\n    Error private immutable _error;\n\n    event Received(address operator, address from, uint256 tokenId, bytes data, uint256 gas);\n\n    constructor(bytes4 retval, Error error) {\n        _retval = retval;\n        _error = error;\n    }\n\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes memory data\n    ) public override returns (bytes4) {\n        if (_error == Error.RevertWithMessage) {\n            revert(\"ERC721ReceiverMock: reverting\");\n        } else if (_error == Error.RevertWithoutMessage) {\n            // solhint-disable-next-line\n            revert();\n        } else if (_error == Error.Panic) {\n            uint256 a = uint256(0) / uint256(0);\n            a;\n        }\n        emit Received(operator, from, tokenId, data, gasleft());\n        return _retval;\n    }\n}\n"
    },
    "contracts/mocks/RelayerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { IETS } from \"../interfaces/IETS.sol\";\nimport { IETSToken } from \"../interfaces/IETSToken.sol\";\nimport { IETSTarget } from \"../interfaces/IETSTarget.sol\";\nimport { IETSRelayer } from \"../relayers/interfaces/IETSRelayer.sol\";\nimport { ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\n\ncontract RelayerMock is ERC165, IETSRelayer, Ownable, Pausable {\n    /// @notice Address and interface for ETS Core.\n    IETS public ets;\n\n    /// @notice Address and interface for ETS Token\n    IETSToken public etsToken;\n\n    /// @notice Address and interface for ETS Target.\n    IETSTarget public etsTarget;\n\n    // Public constants\n\n    /// @notice machine name for this target tagger.\n    string public constant NAME = \"RelayerMock\";\n    bytes4 public constant IID_IETSRELAYER = type(IETSRelayer).interfaceId;\n\n    // Public variables\n\n    /// @notice Address that built this smart contract.\n    address payable public creator;\n\n    constructor(\n        IETS _ets,\n        IETSToken _etsToken,\n        IETSTarget _etsTarget,\n        address payable _creator,\n        address payable _owner\n    ) {\n        ets = _ets;\n        etsToken = _etsToken;\n        etsTarget = _etsTarget;\n        creator = _creator;\n        transferOwnership(_owner);\n    }\n\n    // ============ OWNER INTERFACE ============\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    function changeOwner(address _newOwner) public whenPaused {}\n\n    // ============ PUBLIC INTERFACE ============\n\n    function applyTags(IETS.TaggingRecordRawInput[] calldata _rawParts) public payable {}\n\n    function removeTags(IETS.TaggingRecordRawInput[] calldata _rawParts) public payable {}\n\n    function replaceTags(IETS.TaggingRecordRawInput[] calldata _rawParts) public payable {}\n\n    function getOrCreateTagIds(string[] calldata _tags) public payable returns (uint256[] memory _tagIds) {}\n\n    function computeTaggingFee(\n        IETS.TaggingRecordRawInput calldata _rawInput,\n        IETS.TaggingAction _action\n    ) public view returns (uint256 fee, uint256 tagCount) {}\n\n    // ============ PUBLIC VIEW FUNCTIONS ============\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IETSRelayer) returns (bool) {\n        return interfaceId == IID_IETSRELAYER || super.supportsInterface(interfaceId);\n    }\n\n    function isPaused() public view returns (bool) {}\n\n    function getRelayerName() public pure returns (string memory) {\n        return NAME;\n    }\n\n    function getCreator() public view returns (address payable) {}\n\n    function getOwner() public view returns (address payable) {}\n}\n"
    },
    "contracts/relayers/ETSRelayerBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title ETS Relayer Upgradeable Beacon\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  ███████╗████████╗███████╗\n *  ██╔════╝╚══██╔══╝██╔════╝\n *  █████╗     ██║   ███████╗\n *  ██╔══╝     ██║   ╚════██║\n *  ███████╗   ██║   ███████║\n *  ╚══════╝   ╚═╝   ╚══════╝\n *\n * @notice Upgradeable beacon proxy contract for upgrading the ETS Relayer proxies\n * deployed by ETSRelayerFactory.sol\n */\n\npragma solidity ^0.8.10;\n\nimport { UpgradeableBeacon } from \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract ETSRelayerBeacon is Ownable {\n    UpgradeableBeacon immutable relayerBeacon;\n\n    address public relayerLogic;\n\n    constructor(address _relayerLogic) {\n        relayerBeacon = new UpgradeableBeacon(_relayerLogic);\n        relayerLogic = _relayerLogic;\n        // Assigns ownership to deployer.\n        transferOwnership(tx.origin);\n    }\n\n    function update(address _relayerLogic) public onlyOwner {\n        relayerBeacon.upgradeTo(_relayerLogic);\n        relayerLogic = _relayerLogic;\n    }\n\n    function implementation() public view returns (address) {\n        return relayerBeacon.implementation();\n    }\n}\n"
    },
    "contracts/relayers/ETSRelayerV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title ETS Relayer Version 1\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  ███████╗████████╗███████╗\n *  ██╔════╝╚══██╔══╝██╔════╝\n *  █████╗     ██║   ███████╗\n *  ██╔══╝     ██║   ╚════██║\n *  ███████╗   ██║   ███████║\n *  ╚══════╝   ╚═╝   ╚══════╝\n *\n * @notice Version 1 of upgradeable beacon proxy contract pointed to by ETSRelayerBeacon.sol\n */\n\npragma solidity ^0.8.10;\n\nimport { IETS } from \"../interfaces/IETS.sol\";\nimport { IETSToken } from \"../interfaces/IETSToken.sol\";\nimport { IETSTarget } from \"../interfaces/IETSTarget.sol\";\nimport { IETSRelayer } from \"./interfaces/IETSRelayer.sol\";\nimport { IETSAccessControls } from \"../interfaces/IETSAccessControls.sol\";\nimport { UintArrayUtils } from \"../libraries/UintArrayUtils.sol\";\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { ERC165Upgradeable } from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\ncontract ETSRelayerV1 is\n    IETSRelayer,\n    Initializable,\n    ERC165Upgradeable,\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using UintArrayUtils for uint256[];\n\n    /// @dev Address and interface for ETS Core.\n    IETS public ets;\n\n    /// @dev Address and interface for ETS Token\n    IETSToken public etsToken;\n\n    /// @dev Address and interface for ETS Target.\n    IETSTarget public etsTarget;\n\n    /// @dev Address and interface for ETS Access Controls.\n    IETSAccessControls public etsAccessControls;\n\n    // Public constants\n    string public constant NAME = \"ETS Relayer\";\n    string public constant VERSION = \"0.1-Beta\";\n    bytes4 public constant IID_IETSRELAYER = type(IETSRelayer).interfaceId;\n\n    // Public variables\n\n    /// @notice Address that built this smart contract.\n    address payable public creator;\n\n    /// @dev Public name for Relayer instance.\n    string public relayerName;\n\n    /// Modifiers\n    modifier onlyRelayerAdmin() {\n        require(\n            _msgSender() == owner() || etsAccessControls.hasRole(keccak256(\"RELAYER_ADMIN_ROLE\"), _msgSender()),\n            \"Caller not relayer admin\"\n        );\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        string memory _relayerName,\n        IETS _ets,\n        IETSToken _etsToken,\n        IETSTarget _etsTarget,\n        IETSAccessControls _etsAccessControls,\n        address payable _creator,\n        address payable _owner\n    ) public initializer {\n        __Pausable_init();\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        relayerName = _relayerName;\n        ets = _ets;\n        etsToken = _etsToken;\n        etsTarget = _etsTarget;\n        etsAccessControls = _etsAccessControls;\n        creator = _creator;\n        transferOwnership(_owner);\n    }\n\n    // ============ OWNER INTERFACE ============\n\n    /// @inheritdoc IETSRelayer\n    function pause() public onlyRelayerAdmin {\n        _pause();\n        emit RelayerPauseToggledByOwner(address(this));\n    }\n\n    /// @inheritdoc IETSRelayer\n    function unpause() public onlyRelayerAdmin {\n        // Check that relayer is not paused by platform.\n        require(!etsAccessControls.isRelayerLocked(address(this)), \"Unpausing not permitted\");\n        require(etsToken.balanceOf(owner()) > 0, \"Owner must hold CTAG\");\n        _unpause();\n        emit RelayerPauseToggledByOwner(address(this));\n    }\n\n    /// @inheritdoc IETSRelayer\n    function changeOwner(address _newOwner) public whenPaused onlyOwner {\n        // TODO: check that new owner doesn't already have relayer?\n        etsAccessControls.changeRelayerOwner(owner(), _newOwner);\n        transferOwnership(_newOwner);\n        emit RelayerOwnerChanged(address(this));\n    }\n\n    // ============ PUBLIC INTERFACE ============\n\n    /// @inheritdoc IETSRelayer\n    function applyTags(IETS.TaggingRecordRawInput[] calldata _rawInput) public payable whenNotPaused {\n        uint256 taggingFee = ets.taggingFee();\n        for (uint256 i; i < _rawInput.length; ++i) {\n            _applyTags(_rawInput[i], payable(msg.sender), taggingFee);\n        }\n    }\n\n    /// @inheritdoc IETSRelayer\n    function replaceTags(IETS.TaggingRecordRawInput[] calldata _rawInput) public payable whenNotPaused {\n        uint256 taggingFee = ets.taggingFee();\n        for (uint256 i; i < _rawInput.length; ++i) {\n            _replaceTags(_rawInput[i], payable(msg.sender), taggingFee);\n        }\n    }\n\n    /// @inheritdoc IETSRelayer\n    function removeTags(IETS.TaggingRecordRawInput[] calldata _rawInput) public payable whenNotPaused {\n        for (uint256 i; i < _rawInput.length; ++i) {\n            _removeTags(_rawInput[i], payable(msg.sender));\n        }\n    }\n\n    /// @inheritdoc IETSRelayer\n    function getOrCreateTagIds(\n        string[] calldata _tags\n    ) public payable whenNotPaused returns (uint256[] memory _tagIds) {\n        // First let's derive tagIds for the tagStrings.\n        uint256[] memory tagIds = new uint256[](_tags.length);\n        for (uint256 i; i < _tags.length; ++i) {\n            // for new CTAGs msg.sender is logged as \"creator\" and this contract is \"relayer\"\n            tagIds[i] = ets.getOrCreateTagId(_tags[i], payable(msg.sender));\n        }\n        return tagIds;\n    }\n\n    // ============ PUBLIC VIEW FUNCTIONS ============\n\n    function version() external view virtual returns (string memory) {\n        return VERSION;\n    }\n\n    /// @inheritdoc ERC165Upgradeable\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(ERC165Upgradeable, IETSRelayer) returns (bool) {\n        return interfaceId == IID_IETSRELAYER || super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IETSRelayer\n    function isPaused() public view virtual returns (bool) {\n        return paused();\n    }\n\n    /// @inheritdoc IETSRelayer\n    function getOwner() public view virtual returns (address payable) {\n        return payable(owner());\n    }\n\n    /// @inheritdoc IETSRelayer\n    function getRelayerName() public view returns (string memory) {\n        return relayerName;\n    }\n\n    /// @inheritdoc IETSRelayer\n    function getCreator() public view returns (address payable) {\n        return creator;\n    }\n\n    /// @inheritdoc IETSRelayer\n    function computeTaggingFee(\n        IETS.TaggingRecordRawInput calldata _rawInput,\n        IETS.TaggingAction _action\n    ) public view returns (uint256 fee, uint256 tagCount) {\n        return ets.computeTaggingFeeFromRawInput(_rawInput, address(this), msg.sender, _action);\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    // ============ INTERNAL FUNCTIONS ============\n\n    function _applyTags(\n        IETS.TaggingRecordRawInput calldata _rawInput,\n        address payable _tagger,\n        uint256 _taggingFee\n    ) internal {\n        uint256 valueToSendForTagging = 0;\n        if (_taggingFee > 0) {\n            // This is either a new tagging record or an existing record that's being appended to.\n            // Either way, we need to assess the tagging fees.\n            uint256 actualTagCount = 0;\n            (valueToSendForTagging, actualTagCount) = ets.computeTaggingFeeFromRawInput(\n                _rawInput,\n                address(this),\n                _tagger,\n                IETS.TaggingAction.APPEND\n            );\n            require(address(this).balance >= valueToSendForTagging, \"Insufficient funds\");\n        }\n\n        // Call the core applyTagsWithRawInput() function to record new or append to exsiting tagging record.\n        ets.applyTagsWithRawInput{ value: valueToSendForTagging }(_rawInput, _tagger);\n    }\n\n    function _replaceTags(\n        IETS.TaggingRecordRawInput calldata _rawInput,\n        address payable _tagger,\n        uint256 _taggingFee\n    ) internal {\n        uint256 valueToSendForTagging = 0;\n        if (_taggingFee > 0) {\n            // This is either a new tagging record or an existing record that's being appended to.\n            // Either way, we need to assess the tagging fees.\n            uint256 actualTagCount = 0;\n            (valueToSendForTagging, actualTagCount) = ets.computeTaggingFeeFromRawInput(\n                _rawInput,\n                address(this),\n                _tagger,\n                IETS.TaggingAction.REPLACE\n            );\n            require(address(this).balance >= valueToSendForTagging, \"Insufficient funds\");\n        }\n\n        // Finally, call the core replaceTags() function to update the tagging record.\n        ets.replaceTagsWithRawInput{ value: valueToSendForTagging }(_rawInput, _tagger);\n    }\n\n    function _removeTags(IETS.TaggingRecordRawInput calldata _rawInput, address payable _tagger) internal {\n        ets.removeTagsWithRawInput(_rawInput, _tagger);\n    }\n\n    /* solhint-disable */\n    receive() external payable {}\n\n    fallback() external payable {}\n    /* solhint-enable */\n}\n"
    },
    "contracts/relayers/interfaces/IETSRelayer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title IETSRelayer\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n *  ███████╗████████╗███████╗\n *  ██╔════╝╚══██╔══╝██╔════╝\n *  █████╗     ██║   ███████╗\n *  ██╔══╝     ██║   ╚════██║\n *  ███████╗   ██║   ███████║`\n *  ╚══════╝   ╚═╝   ╚══════╝\n *\n * @notice Minimum interface required for ETS Relayer proxy.\n */\n\npragma solidity ^0.8.10;\n\nimport { IETS } from \"../../interfaces/IETS.sol\";\n\ninterface IETSRelayer {\n    /**\n     * @dev Emitted when an IETSRelayer contract is paused/unpaused by owner.\n     *\n     * @param relayerAddress Address of relayer contract.\n     */\n    event RelayerPauseToggledByOwner(address relayerAddress);\n\n    /**\n     * @dev Emitted when an IETSRelayer contract has changed owners.\n     *\n     * @param relayerAddress Address of relayer contract.\n     */\n    event RelayerOwnerChanged(address relayerAddress);\n\n    // ============ OWNER INTERFACE ============\n\n    /**\n     * @notice Pause this relayer contract.\n     * @dev This function can only be called by the owner when the contract is unpaused.\n     */\n    function pause() external;\n\n    /**\n     * @notice Unpause this relayer contract.\n     * @dev This function can only be called by the owner when the contract is paused.\n     */\n    function unpause() external;\n\n    /**\n     * @notice Transfer this contract to a new owner.\n     *\n     * @dev This function can only be called by the owner when the contract is paused.\n     *\n     * @param newOwner Address of the new contract owner.\n     */\n    function changeOwner(address newOwner) external;\n\n    // ============ PUBLIC VIEW FUNCTIONS ============\n\n    /**\n     * @notice Broadcast support for IETSRelayer interface to external contracts.\n     *\n     * @dev ETSCore will only add relayer contracts that implement IETSRelayer interface.\n     * Your implementation should broadcast that it implements IETSRelayer interface.\n     *\n     * @return boolean: true if this contract implements the interface defined by\n     * `interfaceId`\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    /**\n     * @notice Check whether this contract has been pasued by the owner.\n     *\n     * @dev Pause functionality should be provided by OpenZeppelin Pausable utility.\n     * @return boolean: true for paused; false for not paused.\n     */\n    function isPaused() external view returns (bool);\n\n    /**\n     * @notice Returns address of an IETSRelayer contract owner.\n     *\n     * @return address of contract owner.\n     */\n    function getOwner() external view returns (address payable);\n\n    /**\n     * @notice Returns human readable name for this IETSRelayer contract.\n     *\n     * @return name of the Relayer contract as a string.\n     */\n    function getRelayerName() external view returns (string memory);\n\n    /**\n     * @notice Returns address of an IETSRelayer contract creator.\n     *\n     * @return address of the creator of the Relayer contract.\n     */\n    function getCreator() external view returns (address payable);\n\n    /**\n     * @notice Apply one or more tags to a targetURI using tagging record raw client input data.\n     *\n     * @param _rawInput Raw client input data formed as TaggingRecordRawInput struct.\n     */\n    function applyTags(IETS.TaggingRecordRawInput[] calldata _rawInput) external payable;\n\n    /**\n     * @notice Replace entire tag set in tagging record using raw data for record lookup.\n     *\n     * If supplied tag strings don't have CTAGs, new ones are minted.\n     *\n     * @param _rawInput Raw client input data formed as TaggingRecordRawInput struct.\n     */\n    function replaceTags(IETS.TaggingRecordRawInput[] calldata _rawInput) external payable;\n\n    /**\n     * @notice Remove one or more tags from a tagging record using raw data for record lookup.\n     *\n     * @param _rawInput Raw client input data formed as TaggingRecordRawInput struct.\n     */\n    function removeTags(IETS.TaggingRecordRawInput[] calldata _rawInput) external payable;\n\n    /**\n     * @notice Get or create CTAG tokens from tag strings.\n     *\n     * Combo function that accepts a tag strings and returns corresponding CTAG token Id if it exists,\n     * or if it doesn't exist, creates a new CTAG and then returns corresponding Id.\n     *\n     * Only ETS Publisher contracts may call this function.\n     *\n     * @param _tags Array of tag strings.\n     * @return _tagIds Array of Id of CTAG Ids.\n     */\n    function getOrCreateTagIds(string[] calldata _tags) external payable returns (uint256[] memory _tagIds);\n\n    /**\n     * @notice Compute tagging fee for raw input and desired action.\n     *\n     * @param _rawInput Raw client input data formed as TaggingRecordRawInput struct.\n     * @param _action Integer representing action to be performed according to enum TaggingAction.\n     *\n     * @return fee Calculated tagging fee in ETH/Matic\n     * @return tagCount Number of new tags being added to tagging record.\n     */\n    function computeTaggingFee(\n        IETS.TaggingRecordRawInput calldata _rawInput,\n        IETS.TaggingAction _action\n    ) external view returns (uint256 fee, uint256 tagCount);\n}\n"
    },
    "contracts/test/ETSRelayerV2test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { IETS } from \"../interfaces/IETS.sol\";\nimport { IETSToken } from \"../interfaces/IETSToken.sol\";\nimport { IETSTarget } from \"../interfaces/IETSTarget.sol\";\nimport { IETSRelayer } from \"../relayers/interfaces/IETSRelayer.sol\";\nimport { UintArrayUtils } from \"../libraries/UintArrayUtils.sol\";\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { ERC165Upgradeable } from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\n/**\n * @title ETSRelayerV2test.sol\n * @author Ethereum Tag Service <team@ets.xyz>\n *\n * @notice Test only contract for testing upgrading the implementation contract for the ETSRelayer proxy beacon.\n * In the test suite, ETSRelayerV1.sol is replaced with this contract using the update() function in ETSRelayerBeacon.\n */\ncontract ETSRelayerV2test is\n    IETSRelayer,\n    Initializable,\n    ERC165Upgradeable,\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using UintArrayUtils for uint256[];\n\n    /// @dev Address and interface for ETS Core.\n    IETS public ets;\n\n    /// @dev Address and interface for ETS Token\n    IETSToken public etsToken;\n\n    /// @dev Address and interface for ETS Target.\n    IETSTarget public etsTarget;\n\n    // Public constants\n    string public constant NAME = \"ETS Relayer\";\n    string public constant VERSION = \"0.2-Beta\";\n    bytes4 public constant IID_IETSRELAYER = type(IETSRelayer).interfaceId;\n\n    // Public variables\n\n    /// @notice Address that built this smart contract.\n    address payable public creator;\n\n    /// @dev Public name for Relayer instance.\n    string public relayerName;\n\n    /// Modifiers\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        string memory _relayerName,\n        IETS _ets,\n        IETSToken _etsToken,\n        IETSTarget _etsTarget,\n        address payable _creator,\n        address payable _owner\n    ) public initializer {\n        __Pausable_init();\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        relayerName = _relayerName;\n        ets = _ets;\n        etsToken = _etsToken;\n        etsTarget = _etsTarget;\n        creator = _creator;\n        transferOwnership(_owner);\n    }\n\n    // ============ OWNER INTERFACE ============\n\n    /// @inheritdoc IETSRelayer\n    function pause() public onlyOwner {\n        _pause();\n        emit RelayerPauseToggledByOwner(address(this));\n    }\n\n    /// @inheritdoc IETSRelayer\n    function unpause() public onlyOwner {\n        _unpause();\n        emit RelayerPauseToggledByOwner(address(this));\n    }\n\n    /// @inheritdoc IETSRelayer\n    function changeOwner(address _newOwner) public whenPaused {\n        transferOwnership(_newOwner);\n        emit RelayerOwnerChanged(address(this));\n    }\n\n    // ============ PUBLIC INTERFACE ============\n\n    /// @inheritdoc IETSRelayer\n    function applyTags(IETS.TaggingRecordRawInput[] calldata _rawInput) public payable whenNotPaused {\n        uint256 taggingFee = ets.taggingFee();\n        for (uint256 i; i < _rawInput.length; ++i) {\n            _applyTags(_rawInput[i], payable(msg.sender), taggingFee);\n        }\n    }\n\n    /// @inheritdoc IETSRelayer\n    function replaceTags(IETS.TaggingRecordRawInput[] calldata _rawInput) public payable whenNotPaused {\n        uint256 taggingFee = ets.taggingFee();\n        for (uint256 i; i < _rawInput.length; ++i) {\n            _replaceTags(_rawInput[i], payable(msg.sender), taggingFee);\n        }\n    }\n\n    /// @inheritdoc IETSRelayer\n    function removeTags(IETS.TaggingRecordRawInput[] calldata _rawInput) public payable whenNotPaused {\n        for (uint256 i; i < _rawInput.length; ++i) {\n            _removeTags(_rawInput[i], payable(msg.sender));\n        }\n    }\n\n    /// @inheritdoc IETSRelayer\n    function getOrCreateTagIds(\n        string[] calldata _tags\n    ) public payable whenNotPaused returns (uint256[] memory _tagIds) {\n        // First let's derive tagIds for the tagStrings.\n        uint256[] memory tagIds = new uint256[](_tags.length);\n        for (uint256 i; i < _tags.length; ++i) {\n            // for new CTAGs msg.sender is logged as \"creator\" and this contract is \"relayer\"\n            tagIds[i] = ets.getOrCreateTagId(_tags[i], payable(msg.sender));\n        }\n        return tagIds;\n    }\n\n    // ============ PUBLIC VIEW FUNCTIONS ============\n\n    function version() external view virtual returns (string memory) {\n        return \"0.2-Beta\";\n    }\n\n    /// @inheritdoc ERC165Upgradeable\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(ERC165Upgradeable, IETSRelayer) returns (bool) {\n        return interfaceId == IID_IETSRELAYER || super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IETSRelayer\n    function isPaused() public view virtual returns (bool) {\n        return paused();\n    }\n\n    /// @inheritdoc IETSRelayer\n    function getOwner() public view virtual returns (address payable) {\n        return payable(owner());\n    }\n\n    /// @inheritdoc IETSRelayer\n    function getRelayerName() public view returns (string memory) {\n        return relayerName;\n    }\n\n    /// @inheritdoc IETSRelayer\n    function getCreator() public view returns (address payable) {\n        return creator;\n    }\n\n    /// @inheritdoc IETSRelayer\n    function computeTaggingFee(\n        IETS.TaggingRecordRawInput calldata _rawInput,\n        IETS.TaggingAction _action\n    ) public view returns (uint256 fee, uint256 tagCount) {\n        return ets.computeTaggingFeeFromRawInput(_rawInput, address(this), msg.sender, _action);\n    }\n\n    // ============ INTERNAL FUNCTIONS ============\n\n    function _applyTags(\n        IETS.TaggingRecordRawInput calldata _rawInput,\n        address payable _tagger,\n        uint256 _taggingFee\n    ) internal {\n        uint256 valueToSendForTagging = 0;\n        if (_taggingFee > 0) {\n            // This is either a new tagging record or an existing record that's being appended to.\n            // Either way, we need to assess the tagging fees.\n            uint256 actualTagCount = 0;\n            (valueToSendForTagging, actualTagCount) = ets.computeTaggingFeeFromRawInput(\n                _rawInput,\n                address(this),\n                _tagger,\n                IETS.TaggingAction.APPEND\n            );\n            require(address(this).balance >= valueToSendForTagging, \"Insufficient funds\");\n        }\n\n        // Call the core applyTagsWithRawInput() function to record new or append to exsiting tagging record.\n        ets.applyTagsWithRawInput{ value: valueToSendForTagging }(_rawInput, _tagger);\n    }\n\n    function _replaceTags(\n        IETS.TaggingRecordRawInput calldata _rawInput,\n        address payable _tagger,\n        uint256 _taggingFee\n    ) internal {\n        uint256 valueToSendForTagging = 0;\n        if (_taggingFee > 0) {\n            // This is either a new tagging record or an existing record that's being appended to.\n            // Either way, we need to assess the tagging fees.\n            uint256 actualTagCount = 0;\n            (valueToSendForTagging, actualTagCount) = ets.computeTaggingFeeFromRawInput(\n                _rawInput,\n                address(this),\n                _tagger,\n                IETS.TaggingAction.REPLACE\n            );\n            require(address(this).balance >= valueToSendForTagging, \"Insufficient funds\");\n        }\n\n        // Finally, call the core replaceTags() function to update the tagging record.\n        ets.replaceTagsWithRawInput{ value: valueToSendForTagging }(_rawInput, _tagger);\n    }\n\n    function _removeTags(IETS.TaggingRecordRawInput calldata _rawInput, address payable _tagger) internal {\n        ets.removeTagsWithRawInput(_rawInput, _tagger);\n    }\n\n    function newFunction() public view virtual returns (bool) {\n        return true;\n    }\n}\n"
    },
    "contracts/test/MaliciousBidder.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\nimport { IETSAuctionHouse } from \"../interfaces/IETSAuctionHouse.sol\";\n\ncontract MaliciousBidder {\n    function bid(IETSAuctionHouse auctionHouse, uint256 tokenId) public payable {\n        auctionHouse.createBid{ value: msg.value }(tokenId);\n    }\n\n    receive() external payable {\n        assembly {\n            invalid()\n        }\n    }\n}\n"
    },
    "contracts/test/UUPSTesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { ETSAccessControls } from \"../ETSAccessControls.sol\";\nimport { ETSEnrichTarget } from \"../ETSEnrichTarget.sol\";\nimport { ETSTarget } from \"../ETSTarget.sol\";\nimport { ETSToken } from \"../ETSToken.sol\";\nimport { ETS } from \"../ETS.sol\";\nimport { ETSAuctionHouse } from \"../ETSAuctionHouse.sol\";\n\ncontract ETSAccessControlsUpgrade is ETSAccessControls {\n    // Extend existing contract with new function.\n    function upgradeTest() public pure returns (bool) {\n        return true;\n    }\n}\n\ncontract ETSEnrichTargetUpgrade is ETSEnrichTarget {\n    // Extend existing contract with new function.\n    function upgradeTest() public pure returns (bool) {\n        return true;\n    }\n}\n\ncontract ETSTargetUpgrade is ETSTarget {\n    // Extend existing contract with new function.\n    function upgradeTest() public pure returns (bool) {\n        return true;\n    }\n}\n\ncontract ETSTokenUpgrade is ETSToken {\n    // Extend existing contract with new function.\n    function upgradeTest() public pure returns (bool) {\n        return true;\n    }\n}\n\ncontract ETSUpgrade is ETS {\n    // Extend existing contract with new function.\n    function upgradeTest() public pure returns (bool) {\n        return true;\n    }\n}\n\ncontract ETSAuctionHouseUpgrade is ETSAuctionHouse {\n    // Extend existing contract with new function.\n    function upgradeTest() public pure returns (bool) {\n        return true;\n    }\n}\n"
    },
    "contracts/test/WMATIC.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n// FOR TEST PURPOSES ONLY. NOT PRODUCTION SAFE\n// Source: https://github.com/gnosis/canonical-weth/blob/0dd1ea3e295eef916d0c6223ec63141137d22d67/contracts/WETH9.sol\npragma solidity ^0.8.10;\n\ncontract WMATIC {\n    string public name = \"Wrapped Matic\";\n    string public symbol = \"WMATIC\";\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    fallback() external payable {\n        deposit();\n    }\n\n    receive() external payable {\n        deposit();\n    }\n\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint256 wad) public returns (bool) {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n\n/*\n                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<http://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<http://www.gnu.org/philosophy/why-not-lgpl.html>.\n\n*/\n"
    },
    "contracts/utils/StringHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/// @title StringHelpers Contract\n/// @author Ethereum Tag Service <security@ets.xyz>\n/// @notice Helper functions for common string operations.\nabstract contract StringHelpers {\n    /// @notice Convert a string to its lowercase equivalent.\n    /// @param _base String to convert.\n    /// @return string Lowercase version of string supplied.\n    function __lower(string memory _base) internal pure returns (string memory) {\n        bytes memory bStr = bytes(_base);\n        bytes memory bLower = new bytes(bStr.length);\n        for (uint256 i = 0; i < bStr.length; i++) {\n            // Uppercase character.\n            if ((bStr[i] >= 0x41) && (bStr[i] <= 0x5A)) {\n                // So we add 32 to make it lowercase.\n                bLower[i] = bytes1(uint8(bStr[i]) + 32);\n            } else {\n                bLower[i] = bStr[i];\n            }\n        }\n        return string(bLower);\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}